// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MADS.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MADS_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MADS_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MADS_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MADS_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MADS_2eproto;
namespace MADS {
class AlphanumericalValue;
class AlphanumericalValueDefaultTypeInternal;
extern AlphanumericalValueDefaultTypeInternal _AlphanumericalValue_default_instance_;
class CreateObjectRequest;
class CreateObjectRequestDefaultTypeInternal;
extern CreateObjectRequestDefaultTypeInternal _CreateObjectRequest_default_instance_;
class CreateObjectResponse;
class CreateObjectResponseDefaultTypeInternal;
extern CreateObjectResponseDefaultTypeInternal _CreateObjectResponse_default_instance_;
class CreateTagRequest;
class CreateTagRequestDefaultTypeInternal;
extern CreateTagRequestDefaultTypeInternal _CreateTagRequest_default_instance_;
class CreateTagResponse;
class CreateTagResponseDefaultTypeInternal;
extern CreateTagResponseDefaultTypeInternal _CreateTagResponse_default_instance_;
class CreateTagSetRequest;
class CreateTagSetRequestDefaultTypeInternal;
extern CreateTagSetRequestDefaultTypeInternal _CreateTagSetRequest_default_instance_;
class CreateTagSetResponse;
class CreateTagSetResponseDefaultTypeInternal;
extern CreateTagSetResponseDefaultTypeInternal _CreateTagSetResponse_default_instance_;
class DateValue;
class DateValueDefaultTypeInternal;
extern DateValueDefaultTypeInternal _DateValue_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class GetObjectRequest;
class GetObjectRequestDefaultTypeInternal;
extern GetObjectRequestDefaultTypeInternal _GetObjectRequest_default_instance_;
class GetObjectResponse;
class GetObjectResponseDefaultTypeInternal;
extern GetObjectResponseDefaultTypeInternal _GetObjectResponse_default_instance_;
class GetTagRequest;
class GetTagRequestDefaultTypeInternal;
extern GetTagRequestDefaultTypeInternal _GetTagRequest_default_instance_;
class GetTagResponse;
class GetTagResponseDefaultTypeInternal;
extern GetTagResponseDefaultTypeInternal _GetTagResponse_default_instance_;
class GetTagSetRequest;
class GetTagSetRequestDefaultTypeInternal;
extern GetTagSetRequestDefaultTypeInternal _GetTagSetRequest_default_instance_;
class GetTagSetResponse;
class GetTagSetResponseDefaultTypeInternal;
extern GetTagSetResponseDefaultTypeInternal _GetTagSetResponse_default_instance_;
class GetTagSetsRequest;
class GetTagSetsRequestDefaultTypeInternal;
extern GetTagSetsRequestDefaultTypeInternal _GetTagSetsRequest_default_instance_;
class GetTagSetsResponse;
class GetTagSetsResponseDefaultTypeInternal;
extern GetTagSetsResponseDefaultTypeInternal _GetTagSetsResponse_default_instance_;
class GetTagsRequest;
class GetTagsRequestDefaultTypeInternal;
extern GetTagsRequestDefaultTypeInternal _GetTagsRequest_default_instance_;
class GetTagsResponse;
class GetTagsResponseDefaultTypeInternal;
extern GetTagsResponseDefaultTypeInternal _GetTagsResponse_default_instance_;
class NumericalValue;
class NumericalValueDefaultTypeInternal;
extern NumericalValueDefaultTypeInternal _NumericalValue_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class RGBValue;
class RGBValueDefaultTypeInternal;
extern RGBValueDefaultTypeInternal _RGBValue_default_instance_;
class Tag;
class TagDefaultTypeInternal;
extern TagDefaultTypeInternal _Tag_default_instance_;
class TagSet;
class TagSetDefaultTypeInternal;
extern TagSetDefaultTypeInternal _TagSet_default_instance_;
class TimeValue;
class TimeValueDefaultTypeInternal;
extern TimeValueDefaultTypeInternal _TimeValue_default_instance_;
}  // namespace MADS
PROTOBUF_NAMESPACE_OPEN
template<> ::MADS::AlphanumericalValue* Arena::CreateMaybeMessage<::MADS::AlphanumericalValue>(Arena*);
template<> ::MADS::CreateObjectRequest* Arena::CreateMaybeMessage<::MADS::CreateObjectRequest>(Arena*);
template<> ::MADS::CreateObjectResponse* Arena::CreateMaybeMessage<::MADS::CreateObjectResponse>(Arena*);
template<> ::MADS::CreateTagRequest* Arena::CreateMaybeMessage<::MADS::CreateTagRequest>(Arena*);
template<> ::MADS::CreateTagResponse* Arena::CreateMaybeMessage<::MADS::CreateTagResponse>(Arena*);
template<> ::MADS::CreateTagSetRequest* Arena::CreateMaybeMessage<::MADS::CreateTagSetRequest>(Arena*);
template<> ::MADS::CreateTagSetResponse* Arena::CreateMaybeMessage<::MADS::CreateTagSetResponse>(Arena*);
template<> ::MADS::DateValue* Arena::CreateMaybeMessage<::MADS::DateValue>(Arena*);
template<> ::MADS::Empty* Arena::CreateMaybeMessage<::MADS::Empty>(Arena*);
template<> ::MADS::GetObjectRequest* Arena::CreateMaybeMessage<::MADS::GetObjectRequest>(Arena*);
template<> ::MADS::GetObjectResponse* Arena::CreateMaybeMessage<::MADS::GetObjectResponse>(Arena*);
template<> ::MADS::GetTagRequest* Arena::CreateMaybeMessage<::MADS::GetTagRequest>(Arena*);
template<> ::MADS::GetTagResponse* Arena::CreateMaybeMessage<::MADS::GetTagResponse>(Arena*);
template<> ::MADS::GetTagSetRequest* Arena::CreateMaybeMessage<::MADS::GetTagSetRequest>(Arena*);
template<> ::MADS::GetTagSetResponse* Arena::CreateMaybeMessage<::MADS::GetTagSetResponse>(Arena*);
template<> ::MADS::GetTagSetsRequest* Arena::CreateMaybeMessage<::MADS::GetTagSetsRequest>(Arena*);
template<> ::MADS::GetTagSetsResponse* Arena::CreateMaybeMessage<::MADS::GetTagSetsResponse>(Arena*);
template<> ::MADS::GetTagsRequest* Arena::CreateMaybeMessage<::MADS::GetTagsRequest>(Arena*);
template<> ::MADS::GetTagsResponse* Arena::CreateMaybeMessage<::MADS::GetTagsResponse>(Arena*);
template<> ::MADS::NumericalValue* Arena::CreateMaybeMessage<::MADS::NumericalValue>(Arena*);
template<> ::MADS::Object* Arena::CreateMaybeMessage<::MADS::Object>(Arena*);
template<> ::MADS::RGBValue* Arena::CreateMaybeMessage<::MADS::RGBValue>(Arena*);
template<> ::MADS::Tag* Arena::CreateMaybeMessage<::MADS::Tag>(Arena*);
template<> ::MADS::TagSet* Arena::CreateMaybeMessage<::MADS::TagSet>(Arena*);
template<> ::MADS::TimeValue* Arena::CreateMaybeMessage<::MADS::TimeValue>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace MADS {

enum TagSetType : int {
  TYPE_UNKNOWN = 0,
  ALPHANUMERICAL = 1,
  NUMERICAL = 2,
  DATE = 3,
  TIME = 4,
  RGB = 5,
  TagSetType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TagSetType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TagSetType_IsValid(int value);
constexpr TagSetType TagSetType_MIN = TYPE_UNKNOWN;
constexpr TagSetType TagSetType_MAX = RGB;
constexpr int TagSetType_ARRAYSIZE = TagSetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TagSetType_descriptor();
template<typename T>
inline const std::string& TagSetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TagSetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TagSetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TagSetType_descriptor(), enum_t_value);
}
inline bool TagSetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TagSetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TagSetType>(
    TagSetType_descriptor(), name, value);
}
// ===================================================================

class Object PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  virtual ~Object();

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return CreateMaybeMessage<Object>(nullptr);
  }

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kURIFieldNumber = 2,
    kThumbnailFieldNumber = 3,
    kFileTypeFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // string URI = 2;
  void clear_uri();
  const std::string& uri() const;
  void set_uri(const std::string& value);
  void set_uri(std::string&& value);
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  std::string* mutable_uri();
  std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string thumbnail = 3;
  void clear_thumbnail();
  const std::string& thumbnail() const;
  void set_thumbnail(const std::string& value);
  void set_thumbnail(std::string&& value);
  void set_thumbnail(const char* value);
  void set_thumbnail(const char* value, size_t size);
  std::string* mutable_thumbnail();
  std::string* release_thumbnail();
  void set_allocated_thumbnail(std::string* thumbnail);
  private:
  const std::string& _internal_thumbnail() const;
  void _internal_set_thumbnail(const std::string& value);
  std::string* _internal_mutable_thumbnail();
  public:

  // string fileType = 4;
  void clear_filetype();
  const std::string& filetype() const;
  void set_filetype(const std::string& value);
  void set_filetype(std::string&& value);
  void set_filetype(const char* value);
  void set_filetype(const char* value, size_t size);
  std::string* mutable_filetype();
  std::string* release_filetype();
  void set_allocated_filetype(std::string* filetype);
  private:
  const std::string& _internal_filetype() const;
  void _internal_set_filetype(const std::string& value);
  std::string* _internal_mutable_filetype();
  public:

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:MADS.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filetype_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetObjectRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetObjectRequest) */ {
 public:
  inline GetObjectRequest() : GetObjectRequest(nullptr) {}
  virtual ~GetObjectRequest();

  GetObjectRequest(const GetObjectRequest& from);
  GetObjectRequest(GetObjectRequest&& from) noexcept
    : GetObjectRequest() {
    *this = ::std::move(from);
  }

  inline GetObjectRequest& operator=(const GetObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectRequest& operator=(GetObjectRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetObjectRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetObjectRequest* internal_default_instance() {
    return reinterpret_cast<const GetObjectRequest*>(
               &_GetObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetObjectRequest& a, GetObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetObjectRequest* New() const final {
    return CreateMaybeMessage<GetObjectRequest>(nullptr);
  }

  GetObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetObjectRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetObjectRequest& from);
  void MergeFrom(const GetObjectRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetObjectRequest";
  }
  protected:
  explicit GetObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:MADS.GetObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetObjectResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetObjectResponse) */ {
 public:
  inline GetObjectResponse() : GetObjectResponse(nullptr) {}
  virtual ~GetObjectResponse();

  GetObjectResponse(const GetObjectResponse& from);
  GetObjectResponse(GetObjectResponse&& from) noexcept
    : GetObjectResponse() {
    *this = ::std::move(from);
  }

  inline GetObjectResponse& operator=(const GetObjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectResponse& operator=(GetObjectResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetObjectResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetObjectResponse* internal_default_instance() {
    return reinterpret_cast<const GetObjectResponse*>(
               &_GetObjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetObjectResponse& a, GetObjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetObjectResponse* New() const final {
    return CreateMaybeMessage<GetObjectResponse>(nullptr);
  }

  GetObjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetObjectResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetObjectResponse& from);
  void MergeFrom(const GetObjectResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetObjectResponse";
  }
  protected:
  explicit GetObjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .MADS.Object object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::MADS::Object& object() const;
  ::MADS::Object* release_object();
  ::MADS::Object* mutable_object();
  void set_allocated_object(::MADS::Object* object);
  private:
  const ::MADS::Object& _internal_object() const;
  ::MADS::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::MADS::Object* object);
  ::MADS::Object* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:MADS.GetObjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::MADS::Object* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class CreateObjectRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.CreateObjectRequest) */ {
 public:
  inline CreateObjectRequest() : CreateObjectRequest(nullptr) {}
  virtual ~CreateObjectRequest();

  CreateObjectRequest(const CreateObjectRequest& from);
  CreateObjectRequest(CreateObjectRequest&& from) noexcept
    : CreateObjectRequest() {
    *this = ::std::move(from);
  }

  inline CreateObjectRequest& operator=(const CreateObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateObjectRequest& operator=(CreateObjectRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateObjectRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateObjectRequest* internal_default_instance() {
    return reinterpret_cast<const CreateObjectRequest*>(
               &_CreateObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateObjectRequest& a, CreateObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateObjectRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateObjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateObjectRequest* New() const final {
    return CreateMaybeMessage<CreateObjectRequest>(nullptr);
  }

  CreateObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateObjectRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateObjectRequest& from);
  void MergeFrom(const CreateObjectRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateObjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.CreateObjectRequest";
  }
  protected:
  explicit CreateObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kURIFieldNumber = 1,
    kFileTypeFieldNumber = 3,
  };
  // string URI = 1;
  void clear_uri();
  const std::string& uri() const;
  void set_uri(const std::string& value);
  void set_uri(std::string&& value);
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  std::string* mutable_uri();
  std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string fileType = 3;
  void clear_filetype();
  const std::string& filetype() const;
  void set_filetype(const std::string& value);
  void set_filetype(std::string&& value);
  void set_filetype(const char* value);
  void set_filetype(const char* value, size_t size);
  std::string* mutable_filetype();
  std::string* release_filetype();
  void set_allocated_filetype(std::string* filetype);
  private:
  const std::string& _internal_filetype() const;
  void _internal_set_filetype(const std::string& value);
  std::string* _internal_mutable_filetype();
  public:

  // @@protoc_insertion_point(class_scope:MADS.CreateObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filetype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class CreateObjectResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.CreateObjectResponse) */ {
 public:
  inline CreateObjectResponse() : CreateObjectResponse(nullptr) {}
  virtual ~CreateObjectResponse();

  CreateObjectResponse(const CreateObjectResponse& from);
  CreateObjectResponse(CreateObjectResponse&& from) noexcept
    : CreateObjectResponse() {
    *this = ::std::move(from);
  }

  inline CreateObjectResponse& operator=(const CreateObjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateObjectResponse& operator=(CreateObjectResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateObjectResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateObjectResponse* internal_default_instance() {
    return reinterpret_cast<const CreateObjectResponse*>(
               &_CreateObjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateObjectResponse& a, CreateObjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateObjectResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateObjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateObjectResponse* New() const final {
    return CreateMaybeMessage<CreateObjectResponse>(nullptr);
  }

  CreateObjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateObjectResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateObjectResponse& from);
  void MergeFrom(const CreateObjectResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateObjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.CreateObjectResponse";
  }
  protected:
  explicit CreateObjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .MADS.Object object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::MADS::Object& object() const;
  ::MADS::Object* release_object();
  ::MADS::Object* mutable_object();
  void set_allocated_object(::MADS::Object* object);
  private:
  const ::MADS::Object& _internal_object() const;
  ::MADS::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::MADS::Object* object);
  ::MADS::Object* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:MADS.CreateObjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::MADS::Object* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class TagSet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.TagSet) */ {
 public:
  inline TagSet() : TagSet(nullptr) {}
  virtual ~TagSet();

  TagSet(const TagSet& from);
  TagSet(TagSet&& from) noexcept
    : TagSet() {
    *this = ::std::move(from);
  }

  inline TagSet& operator=(const TagSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagSet& operator=(TagSet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TagSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TagSet* internal_default_instance() {
    return reinterpret_cast<const TagSet*>(
               &_TagSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TagSet& a, TagSet& b) {
    a.Swap(&b);
  }
  inline void Swap(TagSet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagSet* New() const final {
    return CreateMaybeMessage<TagSet>(nullptr);
  }

  TagSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagSet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TagSet& from);
  void MergeFrom(const TagSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.TagSet";
  }
  protected:
  explicit TagSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kIdFieldNumber = 1,
    kAccessIdFieldNumber = 5,
    kTypeFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 accessId = 5;
  void clear_accessid();
  ::PROTOBUF_NAMESPACE_ID::int64 accessid() const;
  void set_accessid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_accessid() const;
  void _internal_set_accessid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .MADS.TagSetType type = 4;
  void clear_type();
  ::MADS::TagSetType type() const;
  void set_type(::MADS::TagSetType value);
  private:
  ::MADS::TagSetType _internal_type() const;
  void _internal_set_type(::MADS::TagSetType value);
  public:

  // @@protoc_insertion_point(class_scope:MADS.TagSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 accessid_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetTagSetsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetTagSetsRequest) */ {
 public:
  inline GetTagSetsRequest() : GetTagSetsRequest(nullptr) {}
  virtual ~GetTagSetsRequest();

  GetTagSetsRequest(const GetTagSetsRequest& from);
  GetTagSetsRequest(GetTagSetsRequest&& from) noexcept
    : GetTagSetsRequest() {
    *this = ::std::move(from);
  }

  inline GetTagSetsRequest& operator=(const GetTagSetsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTagSetsRequest& operator=(GetTagSetsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTagSetsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTagSetsRequest* internal_default_instance() {
    return reinterpret_cast<const GetTagSetsRequest*>(
               &_GetTagSetsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetTagSetsRequest& a, GetTagSetsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTagSetsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTagSetsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTagSetsRequest* New() const final {
    return CreateMaybeMessage<GetTagSetsRequest>(nullptr);
  }

  GetTagSetsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTagSetsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTagSetsRequest& from);
  void MergeFrom(const GetTagSetsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTagSetsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetTagSetsRequest";
  }
  protected:
  explicit GetTagSetsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MADS.GetTagSetsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetTagSetsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetTagSetsResponse) */ {
 public:
  inline GetTagSetsResponse() : GetTagSetsResponse(nullptr) {}
  virtual ~GetTagSetsResponse();

  GetTagSetsResponse(const GetTagSetsResponse& from);
  GetTagSetsResponse(GetTagSetsResponse&& from) noexcept
    : GetTagSetsResponse() {
    *this = ::std::move(from);
  }

  inline GetTagSetsResponse& operator=(const GetTagSetsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTagSetsResponse& operator=(GetTagSetsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTagSetsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTagSetsResponse* internal_default_instance() {
    return reinterpret_cast<const GetTagSetsResponse*>(
               &_GetTagSetsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetTagSetsResponse& a, GetTagSetsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTagSetsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTagSetsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTagSetsResponse* New() const final {
    return CreateMaybeMessage<GetTagSetsResponse>(nullptr);
  }

  GetTagSetsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTagSetsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTagSetsResponse& from);
  void MergeFrom(const GetTagSetsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTagSetsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetTagSetsResponse";
  }
  protected:
  explicit GetTagSetsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsetsFieldNumber = 1,
  };
  // repeated .MADS.TagSet tagsets = 1;
  int tagsets_size() const;
  private:
  int _internal_tagsets_size() const;
  public:
  void clear_tagsets();
  ::MADS::TagSet* mutable_tagsets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::TagSet >*
      mutable_tagsets();
  private:
  const ::MADS::TagSet& _internal_tagsets(int index) const;
  ::MADS::TagSet* _internal_add_tagsets();
  public:
  const ::MADS::TagSet& tagsets(int index) const;
  ::MADS::TagSet* add_tagsets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::TagSet >&
      tagsets() const;

  // @@protoc_insertion_point(class_scope:MADS.GetTagSetsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::TagSet > tagsets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetTagSetRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetTagSetRequest) */ {
 public:
  inline GetTagSetRequest() : GetTagSetRequest(nullptr) {}
  virtual ~GetTagSetRequest();

  GetTagSetRequest(const GetTagSetRequest& from);
  GetTagSetRequest(GetTagSetRequest&& from) noexcept
    : GetTagSetRequest() {
    *this = ::std::move(from);
  }

  inline GetTagSetRequest& operator=(const GetTagSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTagSetRequest& operator=(GetTagSetRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTagSetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTagSetRequest* internal_default_instance() {
    return reinterpret_cast<const GetTagSetRequest*>(
               &_GetTagSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetTagSetRequest& a, GetTagSetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTagSetRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTagSetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTagSetRequest* New() const final {
    return CreateMaybeMessage<GetTagSetRequest>(nullptr);
  }

  GetTagSetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTagSetRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTagSetRequest& from);
  void MergeFrom(const GetTagSetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTagSetRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetTagSetRequest";
  }
  protected:
  explicit GetTagSetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:MADS.GetTagSetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetTagSetResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetTagSetResponse) */ {
 public:
  inline GetTagSetResponse() : GetTagSetResponse(nullptr) {}
  virtual ~GetTagSetResponse();

  GetTagSetResponse(const GetTagSetResponse& from);
  GetTagSetResponse(GetTagSetResponse&& from) noexcept
    : GetTagSetResponse() {
    *this = ::std::move(from);
  }

  inline GetTagSetResponse& operator=(const GetTagSetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTagSetResponse& operator=(GetTagSetResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTagSetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTagSetResponse* internal_default_instance() {
    return reinterpret_cast<const GetTagSetResponse*>(
               &_GetTagSetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetTagSetResponse& a, GetTagSetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTagSetResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTagSetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTagSetResponse* New() const final {
    return CreateMaybeMessage<GetTagSetResponse>(nullptr);
  }

  GetTagSetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTagSetResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTagSetResponse& from);
  void MergeFrom(const GetTagSetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTagSetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetTagSetResponse";
  }
  protected:
  explicit GetTagSetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsetFieldNumber = 1,
  };
  // .MADS.TagSet tagset = 1;
  bool has_tagset() const;
  private:
  bool _internal_has_tagset() const;
  public:
  void clear_tagset();
  const ::MADS::TagSet& tagset() const;
  ::MADS::TagSet* release_tagset();
  ::MADS::TagSet* mutable_tagset();
  void set_allocated_tagset(::MADS::TagSet* tagset);
  private:
  const ::MADS::TagSet& _internal_tagset() const;
  ::MADS::TagSet* _internal_mutable_tagset();
  public:
  void unsafe_arena_set_allocated_tagset(
      ::MADS::TagSet* tagset);
  ::MADS::TagSet* unsafe_arena_release_tagset();

  // @@protoc_insertion_point(class_scope:MADS.GetTagSetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::MADS::TagSet* tagset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class CreateTagSetRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.CreateTagSetRequest) */ {
 public:
  inline CreateTagSetRequest() : CreateTagSetRequest(nullptr) {}
  virtual ~CreateTagSetRequest();

  CreateTagSetRequest(const CreateTagSetRequest& from);
  CreateTagSetRequest(CreateTagSetRequest&& from) noexcept
    : CreateTagSetRequest() {
    *this = ::std::move(from);
  }

  inline CreateTagSetRequest& operator=(const CreateTagSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTagSetRequest& operator=(CreateTagSetRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateTagSetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTagSetRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTagSetRequest*>(
               &_CreateTagSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateTagSetRequest& a, CreateTagSetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTagSetRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTagSetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTagSetRequest* New() const final {
    return CreateMaybeMessage<CreateTagSetRequest>(nullptr);
  }

  CreateTagSetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTagSetRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateTagSetRequest& from);
  void MergeFrom(const CreateTagSetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTagSetRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.CreateTagSetRequest";
  }
  protected:
  explicit CreateTagSetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .MADS.TagSetType type = 3;
  void clear_type();
  ::MADS::TagSetType type() const;
  void set_type(::MADS::TagSetType value);
  private:
  ::MADS::TagSetType _internal_type() const;
  void _internal_set_type(::MADS::TagSetType value);
  public:

  // @@protoc_insertion_point(class_scope:MADS.CreateTagSetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class CreateTagSetResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.CreateTagSetResponse) */ {
 public:
  inline CreateTagSetResponse() : CreateTagSetResponse(nullptr) {}
  virtual ~CreateTagSetResponse();

  CreateTagSetResponse(const CreateTagSetResponse& from);
  CreateTagSetResponse(CreateTagSetResponse&& from) noexcept
    : CreateTagSetResponse() {
    *this = ::std::move(from);
  }

  inline CreateTagSetResponse& operator=(const CreateTagSetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTagSetResponse& operator=(CreateTagSetResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateTagSetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTagSetResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTagSetResponse*>(
               &_CreateTagSetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreateTagSetResponse& a, CreateTagSetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTagSetResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTagSetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTagSetResponse* New() const final {
    return CreateMaybeMessage<CreateTagSetResponse>(nullptr);
  }

  CreateTagSetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTagSetResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateTagSetResponse& from);
  void MergeFrom(const CreateTagSetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTagSetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.CreateTagSetResponse";
  }
  protected:
  explicit CreateTagSetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsetFieldNumber = 1,
  };
  // .MADS.TagSet tagset = 1;
  bool has_tagset() const;
  private:
  bool _internal_has_tagset() const;
  public:
  void clear_tagset();
  const ::MADS::TagSet& tagset() const;
  ::MADS::TagSet* release_tagset();
  ::MADS::TagSet* mutable_tagset();
  void set_allocated_tagset(::MADS::TagSet* tagset);
  private:
  const ::MADS::TagSet& _internal_tagset() const;
  ::MADS::TagSet* _internal_mutable_tagset();
  public:
  void unsafe_arena_set_allocated_tagset(
      ::MADS::TagSet* tagset);
  ::MADS::TagSet* unsafe_arena_release_tagset();

  // @@protoc_insertion_point(class_scope:MADS.CreateTagSetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::MADS::TagSet* tagset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class AlphanumericalValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.AlphanumericalValue) */ {
 public:
  inline AlphanumericalValue() : AlphanumericalValue(nullptr) {}
  virtual ~AlphanumericalValue();

  AlphanumericalValue(const AlphanumericalValue& from);
  AlphanumericalValue(AlphanumericalValue&& from) noexcept
    : AlphanumericalValue() {
    *this = ::std::move(from);
  }

  inline AlphanumericalValue& operator=(const AlphanumericalValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlphanumericalValue& operator=(AlphanumericalValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AlphanumericalValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AlphanumericalValue* internal_default_instance() {
    return reinterpret_cast<const AlphanumericalValue*>(
               &_AlphanumericalValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AlphanumericalValue& a, AlphanumericalValue& b) {
    a.Swap(&b);
  }
  inline void Swap(AlphanumericalValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlphanumericalValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AlphanumericalValue* New() const final {
    return CreateMaybeMessage<AlphanumericalValue>(nullptr);
  }

  AlphanumericalValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AlphanumericalValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AlphanumericalValue& from);
  void MergeFrom(const AlphanumericalValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlphanumericalValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.AlphanumericalValue";
  }
  protected:
  explicit AlphanumericalValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:MADS.AlphanumericalValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class NumericalValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.NumericalValue) */ {
 public:
  inline NumericalValue() : NumericalValue(nullptr) {}
  virtual ~NumericalValue();

  NumericalValue(const NumericalValue& from);
  NumericalValue(NumericalValue&& from) noexcept
    : NumericalValue() {
    *this = ::std::move(from);
  }

  inline NumericalValue& operator=(const NumericalValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumericalValue& operator=(NumericalValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NumericalValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NumericalValue* internal_default_instance() {
    return reinterpret_cast<const NumericalValue*>(
               &_NumericalValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NumericalValue& a, NumericalValue& b) {
    a.Swap(&b);
  }
  inline void Swap(NumericalValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumericalValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NumericalValue* New() const final {
    return CreateMaybeMessage<NumericalValue>(nullptr);
  }

  NumericalValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NumericalValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NumericalValue& from);
  void MergeFrom(const NumericalValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumericalValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.NumericalValue";
  }
  protected:
  explicit NumericalValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:MADS.NumericalValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class DateValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.DateValue) */ {
 public:
  inline DateValue() : DateValue(nullptr) {}
  virtual ~DateValue();

  DateValue(const DateValue& from);
  DateValue(DateValue&& from) noexcept
    : DateValue() {
    *this = ::std::move(from);
  }

  inline DateValue& operator=(const DateValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateValue& operator=(DateValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DateValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DateValue* internal_default_instance() {
    return reinterpret_cast<const DateValue*>(
               &_DateValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DateValue& a, DateValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DateValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DateValue* New() const final {
    return CreateMaybeMessage<DateValue>(nullptr);
  }

  DateValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DateValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DateValue& from);
  void MergeFrom(const DateValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DateValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.DateValue";
  }
  protected:
  explicit DateValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:MADS.DateValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class TimeValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.TimeValue) */ {
 public:
  inline TimeValue() : TimeValue(nullptr) {}
  virtual ~TimeValue();

  TimeValue(const TimeValue& from);
  TimeValue(TimeValue&& from) noexcept
    : TimeValue() {
    *this = ::std::move(from);
  }

  inline TimeValue& operator=(const TimeValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeValue& operator=(TimeValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimeValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeValue* internal_default_instance() {
    return reinterpret_cast<const TimeValue*>(
               &_TimeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TimeValue& a, TimeValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimeValue* New() const final {
    return CreateMaybeMessage<TimeValue>(nullptr);
  }

  TimeValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimeValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimeValue& from);
  void MergeFrom(const TimeValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.TimeValue";
  }
  protected:
  explicit TimeValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:MADS.TimeValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class RGBValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.RGBValue) */ {
 public:
  inline RGBValue() : RGBValue(nullptr) {}
  virtual ~RGBValue();

  RGBValue(const RGBValue& from);
  RGBValue(RGBValue&& from) noexcept
    : RGBValue() {
    *this = ::std::move(from);
  }

  inline RGBValue& operator=(const RGBValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline RGBValue& operator=(RGBValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RGBValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RGBValue* internal_default_instance() {
    return reinterpret_cast<const RGBValue*>(
               &_RGBValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RGBValue& a, RGBValue& b) {
    a.Swap(&b);
  }
  inline void Swap(RGBValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RGBValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RGBValue* New() const final {
    return CreateMaybeMessage<RGBValue>(nullptr);
  }

  RGBValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RGBValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RGBValue& from);
  void MergeFrom(const RGBValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RGBValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.RGBValue";
  }
  protected:
  explicit RGBValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedFieldNumber = 1,
    kGreenFieldNumber = 2,
    kBlueFieldNumber = 3,
  };
  // int64 red = 1;
  void clear_red();
  ::PROTOBUF_NAMESPACE_ID::int64 red() const;
  void set_red(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_red() const;
  void _internal_set_red(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 green = 2;
  void clear_green();
  ::PROTOBUF_NAMESPACE_ID::int64 green() const;
  void set_green(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_green() const;
  void _internal_set_green(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 blue = 3;
  void clear_blue();
  ::PROTOBUF_NAMESPACE_ID::int64 blue() const;
  void set_blue(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_blue() const;
  void _internal_set_blue(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:MADS.RGBValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 red_;
  ::PROTOBUF_NAMESPACE_ID::int64 green_;
  ::PROTOBUF_NAMESPACE_ID::int64 blue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class Tag PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.Tag) */ {
 public:
  inline Tag() : Tag(nullptr) {}
  virtual ~Tag();

  Tag(const Tag& from);
  Tag(Tag&& from) noexcept
    : Tag() {
    *this = ::std::move(from);
  }

  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tag& operator=(Tag&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tag& default_instance();

  enum ValueCase {
    kAlphanumerical = 4,
    kNumerical = 5,
    kDate = 6,
    kTime = 7,
    kRgb = 8,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tag* internal_default_instance() {
    return reinterpret_cast<const Tag*>(
               &_Tag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Tag& a, Tag& b) {
    a.Swap(&b);
  }
  inline void Swap(Tag* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tag* New() const final {
    return CreateMaybeMessage<Tag>(nullptr);
  }

  Tag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tag& from);
  void MergeFrom(const Tag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.Tag";
  }
  protected:
  explicit Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTagSetIdFieldNumber = 2,
    kTypeIdFieldNumber = 3,
    kAlphanumericalFieldNumber = 4,
    kNumericalFieldNumber = 5,
    kDateFieldNumber = 6,
    kTimeFieldNumber = 7,
    kRgbFieldNumber = 8,
  };
  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 tagSetId = 2;
  void clear_tagsetid();
  ::PROTOBUF_NAMESPACE_ID::int64 tagsetid() const;
  void set_tagsetid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tagsetid() const;
  void _internal_set_tagsetid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 typeId = 3;
  void clear_typeid_();
  ::PROTOBUF_NAMESPACE_ID::int64 typeid_() const;
  void set_typeid_(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_typeid_() const;
  void _internal_set_typeid_(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .MADS.AlphanumericalValue alphanumerical = 4;
  bool has_alphanumerical() const;
  private:
  bool _internal_has_alphanumerical() const;
  public:
  void clear_alphanumerical();
  const ::MADS::AlphanumericalValue& alphanumerical() const;
  ::MADS::AlphanumericalValue* release_alphanumerical();
  ::MADS::AlphanumericalValue* mutable_alphanumerical();
  void set_allocated_alphanumerical(::MADS::AlphanumericalValue* alphanumerical);
  private:
  const ::MADS::AlphanumericalValue& _internal_alphanumerical() const;
  ::MADS::AlphanumericalValue* _internal_mutable_alphanumerical();
  public:
  void unsafe_arena_set_allocated_alphanumerical(
      ::MADS::AlphanumericalValue* alphanumerical);
  ::MADS::AlphanumericalValue* unsafe_arena_release_alphanumerical();

  // .MADS.NumericalValue numerical = 5;
  bool has_numerical() const;
  private:
  bool _internal_has_numerical() const;
  public:
  void clear_numerical();
  const ::MADS::NumericalValue& numerical() const;
  ::MADS::NumericalValue* release_numerical();
  ::MADS::NumericalValue* mutable_numerical();
  void set_allocated_numerical(::MADS::NumericalValue* numerical);
  private:
  const ::MADS::NumericalValue& _internal_numerical() const;
  ::MADS::NumericalValue* _internal_mutable_numerical();
  public:
  void unsafe_arena_set_allocated_numerical(
      ::MADS::NumericalValue* numerical);
  ::MADS::NumericalValue* unsafe_arena_release_numerical();

  // .MADS.DateValue date = 6;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const ::MADS::DateValue& date() const;
  ::MADS::DateValue* release_date();
  ::MADS::DateValue* mutable_date();
  void set_allocated_date(::MADS::DateValue* date);
  private:
  const ::MADS::DateValue& _internal_date() const;
  ::MADS::DateValue* _internal_mutable_date();
  public:
  void unsafe_arena_set_allocated_date(
      ::MADS::DateValue* date);
  ::MADS::DateValue* unsafe_arena_release_date();

  // .MADS.TimeValue time = 7;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::MADS::TimeValue& time() const;
  ::MADS::TimeValue* release_time();
  ::MADS::TimeValue* mutable_time();
  void set_allocated_time(::MADS::TimeValue* time);
  private:
  const ::MADS::TimeValue& _internal_time() const;
  ::MADS::TimeValue* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::MADS::TimeValue* time);
  ::MADS::TimeValue* unsafe_arena_release_time();

  // .MADS.RGBValue rgb = 8;
  bool has_rgb() const;
  private:
  bool _internal_has_rgb() const;
  public:
  void clear_rgb();
  const ::MADS::RGBValue& rgb() const;
  ::MADS::RGBValue* release_rgb();
  ::MADS::RGBValue* mutable_rgb();
  void set_allocated_rgb(::MADS::RGBValue* rgb);
  private:
  const ::MADS::RGBValue& _internal_rgb() const;
  ::MADS::RGBValue* _internal_mutable_rgb();
  public:
  void unsafe_arena_set_allocated_rgb(
      ::MADS::RGBValue* rgb);
  ::MADS::RGBValue* unsafe_arena_release_rgb();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:MADS.Tag)
 private:
  class _Internal;
  void set_has_alphanumerical();
  void set_has_numerical();
  void set_has_date();
  void set_has_time();
  void set_has_rgb();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 tagsetid_;
  ::PROTOBUF_NAMESPACE_ID::int64 typeid__;
  union ValueUnion {
    ValueUnion() {}
    ::MADS::AlphanumericalValue* alphanumerical_;
    ::MADS::NumericalValue* numerical_;
    ::MADS::DateValue* date_;
    ::MADS::TimeValue* time_;
    ::MADS::RGBValue* rgb_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetTagsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetTagsRequest) */ {
 public:
  inline GetTagsRequest() : GetTagsRequest(nullptr) {}
  virtual ~GetTagsRequest();

  GetTagsRequest(const GetTagsRequest& from);
  GetTagsRequest(GetTagsRequest&& from) noexcept
    : GetTagsRequest() {
    *this = ::std::move(from);
  }

  inline GetTagsRequest& operator=(const GetTagsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTagsRequest& operator=(GetTagsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTagsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTagsRequest* internal_default_instance() {
    return reinterpret_cast<const GetTagsRequest*>(
               &_GetTagsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetTagsRequest& a, GetTagsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTagsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTagsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTagsRequest* New() const final {
    return CreateMaybeMessage<GetTagsRequest>(nullptr);
  }

  GetTagsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTagsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTagsRequest& from);
  void MergeFrom(const GetTagsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTagsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetTagsRequest";
  }
  protected:
  explicit GetTagsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MADS.GetTagsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetTagsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetTagsResponse) */ {
 public:
  inline GetTagsResponse() : GetTagsResponse(nullptr) {}
  virtual ~GetTagsResponse();

  GetTagsResponse(const GetTagsResponse& from);
  GetTagsResponse(GetTagsResponse&& from) noexcept
    : GetTagsResponse() {
    *this = ::std::move(from);
  }

  inline GetTagsResponse& operator=(const GetTagsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTagsResponse& operator=(GetTagsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTagsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTagsResponse* internal_default_instance() {
    return reinterpret_cast<const GetTagsResponse*>(
               &_GetTagsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetTagsResponse& a, GetTagsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTagsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTagsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTagsResponse* New() const final {
    return CreateMaybeMessage<GetTagsResponse>(nullptr);
  }

  GetTagsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTagsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTagsResponse& from);
  void MergeFrom(const GetTagsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTagsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetTagsResponse";
  }
  protected:
  explicit GetTagsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
  };
  // repeated .MADS.Tag tags = 1;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::MADS::Tag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::Tag >*
      mutable_tags();
  private:
  const ::MADS::Tag& _internal_tags(int index) const;
  ::MADS::Tag* _internal_add_tags();
  public:
  const ::MADS::Tag& tags(int index) const;
  ::MADS::Tag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::Tag >&
      tags() const;

  // @@protoc_insertion_point(class_scope:MADS.GetTagsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::Tag > tags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetTagRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetTagRequest) */ {
 public:
  inline GetTagRequest() : GetTagRequest(nullptr) {}
  virtual ~GetTagRequest();

  GetTagRequest(const GetTagRequest& from);
  GetTagRequest(GetTagRequest&& from) noexcept
    : GetTagRequest() {
    *this = ::std::move(from);
  }

  inline GetTagRequest& operator=(const GetTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTagRequest& operator=(GetTagRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTagRequest* internal_default_instance() {
    return reinterpret_cast<const GetTagRequest*>(
               &_GetTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetTagRequest& a, GetTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTagRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTagRequest* New() const final {
    return CreateMaybeMessage<GetTagRequest>(nullptr);
  }

  GetTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTagRequest& from);
  void MergeFrom(const GetTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetTagRequest";
  }
  protected:
  explicit GetTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:MADS.GetTagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class GetTagResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.GetTagResponse) */ {
 public:
  inline GetTagResponse() : GetTagResponse(nullptr) {}
  virtual ~GetTagResponse();

  GetTagResponse(const GetTagResponse& from);
  GetTagResponse(GetTagResponse&& from) noexcept
    : GetTagResponse() {
    *this = ::std::move(from);
  }

  inline GetTagResponse& operator=(const GetTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTagResponse& operator=(GetTagResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTagResponse* internal_default_instance() {
    return reinterpret_cast<const GetTagResponse*>(
               &_GetTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetTagResponse& a, GetTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTagResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTagResponse* New() const final {
    return CreateMaybeMessage<GetTagResponse>(nullptr);
  }

  GetTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTagResponse& from);
  void MergeFrom(const GetTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.GetTagResponse";
  }
  protected:
  explicit GetTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
  };
  // .MADS.Tag tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const ::MADS::Tag& tag() const;
  ::MADS::Tag* release_tag();
  ::MADS::Tag* mutable_tag();
  void set_allocated_tag(::MADS::Tag* tag);
  private:
  const ::MADS::Tag& _internal_tag() const;
  ::MADS::Tag* _internal_mutable_tag();
  public:
  void unsafe_arena_set_allocated_tag(
      ::MADS::Tag* tag);
  ::MADS::Tag* unsafe_arena_release_tag();

  // @@protoc_insertion_point(class_scope:MADS.GetTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::MADS::Tag* tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class CreateTagRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.CreateTagRequest) */ {
 public:
  inline CreateTagRequest() : CreateTagRequest(nullptr) {}
  virtual ~CreateTagRequest();

  CreateTagRequest(const CreateTagRequest& from);
  CreateTagRequest(CreateTagRequest&& from) noexcept
    : CreateTagRequest() {
    *this = ::std::move(from);
  }

  inline CreateTagRequest& operator=(const CreateTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTagRequest& operator=(CreateTagRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateTagRequest& default_instance();

  enum ValueCase {
    kAlphanumerical = 4,
    kNumerical = 5,
    kDate = 6,
    kTime = 7,
    kRgb = 8,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTagRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTagRequest*>(
               &_CreateTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CreateTagRequest& a, CreateTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTagRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTagRequest* New() const final {
    return CreateMaybeMessage<CreateTagRequest>(nullptr);
  }

  CreateTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateTagRequest& from);
  void MergeFrom(const CreateTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.CreateTagRequest";
  }
  protected:
  explicit CreateTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagSetIdFieldNumber = 1,
    kAlphanumericalFieldNumber = 4,
    kNumericalFieldNumber = 5,
    kDateFieldNumber = 6,
    kTimeFieldNumber = 7,
    kRgbFieldNumber = 8,
  };
  // int64 tagSetId = 1;
  void clear_tagsetid();
  ::PROTOBUF_NAMESPACE_ID::int64 tagsetid() const;
  void set_tagsetid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tagsetid() const;
  void _internal_set_tagsetid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .MADS.AlphanumericalValue alphanumerical = 4;
  bool has_alphanumerical() const;
  private:
  bool _internal_has_alphanumerical() const;
  public:
  void clear_alphanumerical();
  const ::MADS::AlphanumericalValue& alphanumerical() const;
  ::MADS::AlphanumericalValue* release_alphanumerical();
  ::MADS::AlphanumericalValue* mutable_alphanumerical();
  void set_allocated_alphanumerical(::MADS::AlphanumericalValue* alphanumerical);
  private:
  const ::MADS::AlphanumericalValue& _internal_alphanumerical() const;
  ::MADS::AlphanumericalValue* _internal_mutable_alphanumerical();
  public:
  void unsafe_arena_set_allocated_alphanumerical(
      ::MADS::AlphanumericalValue* alphanumerical);
  ::MADS::AlphanumericalValue* unsafe_arena_release_alphanumerical();

  // .MADS.NumericalValue numerical = 5;
  bool has_numerical() const;
  private:
  bool _internal_has_numerical() const;
  public:
  void clear_numerical();
  const ::MADS::NumericalValue& numerical() const;
  ::MADS::NumericalValue* release_numerical();
  ::MADS::NumericalValue* mutable_numerical();
  void set_allocated_numerical(::MADS::NumericalValue* numerical);
  private:
  const ::MADS::NumericalValue& _internal_numerical() const;
  ::MADS::NumericalValue* _internal_mutable_numerical();
  public:
  void unsafe_arena_set_allocated_numerical(
      ::MADS::NumericalValue* numerical);
  ::MADS::NumericalValue* unsafe_arena_release_numerical();

  // .MADS.DateValue date = 6;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const ::MADS::DateValue& date() const;
  ::MADS::DateValue* release_date();
  ::MADS::DateValue* mutable_date();
  void set_allocated_date(::MADS::DateValue* date);
  private:
  const ::MADS::DateValue& _internal_date() const;
  ::MADS::DateValue* _internal_mutable_date();
  public:
  void unsafe_arena_set_allocated_date(
      ::MADS::DateValue* date);
  ::MADS::DateValue* unsafe_arena_release_date();

  // .MADS.TimeValue time = 7;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::MADS::TimeValue& time() const;
  ::MADS::TimeValue* release_time();
  ::MADS::TimeValue* mutable_time();
  void set_allocated_time(::MADS::TimeValue* time);
  private:
  const ::MADS::TimeValue& _internal_time() const;
  ::MADS::TimeValue* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::MADS::TimeValue* time);
  ::MADS::TimeValue* unsafe_arena_release_time();

  // .MADS.RGBValue rgb = 8;
  bool has_rgb() const;
  private:
  bool _internal_has_rgb() const;
  public:
  void clear_rgb();
  const ::MADS::RGBValue& rgb() const;
  ::MADS::RGBValue* release_rgb();
  ::MADS::RGBValue* mutable_rgb();
  void set_allocated_rgb(::MADS::RGBValue* rgb);
  private:
  const ::MADS::RGBValue& _internal_rgb() const;
  ::MADS::RGBValue* _internal_mutable_rgb();
  public:
  void unsafe_arena_set_allocated_rgb(
      ::MADS::RGBValue* rgb);
  ::MADS::RGBValue* unsafe_arena_release_rgb();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:MADS.CreateTagRequest)
 private:
  class _Internal;
  void set_has_alphanumerical();
  void set_has_numerical();
  void set_has_date();
  void set_has_time();
  void set_has_rgb();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 tagsetid_;
  union ValueUnion {
    ValueUnion() {}
    ::MADS::AlphanumericalValue* alphanumerical_;
    ::MADS::NumericalValue* numerical_;
    ::MADS::DateValue* date_;
    ::MADS::TimeValue* time_;
    ::MADS::RGBValue* rgb_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class CreateTagResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.CreateTagResponse) */ {
 public:
  inline CreateTagResponse() : CreateTagResponse(nullptr) {}
  virtual ~CreateTagResponse();

  CreateTagResponse(const CreateTagResponse& from);
  CreateTagResponse(CreateTagResponse&& from) noexcept
    : CreateTagResponse() {
    *this = ::std::move(from);
  }

  inline CreateTagResponse& operator=(const CreateTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTagResponse& operator=(CreateTagResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTagResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTagResponse*>(
               &_CreateTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CreateTagResponse& a, CreateTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTagResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTagResponse* New() const final {
    return CreateMaybeMessage<CreateTagResponse>(nullptr);
  }

  CreateTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateTagResponse& from);
  void MergeFrom(const CreateTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.CreateTagResponse";
  }
  protected:
  explicit CreateTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
  };
  // .MADS.Tag tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const ::MADS::Tag& tag() const;
  ::MADS::Tag* release_tag();
  ::MADS::Tag* mutable_tag();
  void set_allocated_tag(::MADS::Tag* tag);
  private:
  const ::MADS::Tag& _internal_tag() const;
  ::MADS::Tag* _internal_mutable_tag();
  public:
  void unsafe_arena_set_allocated_tag(
      ::MADS::Tag* tag);
  ::MADS::Tag* unsafe_arena_release_tag();

  // @@protoc_insertion_point(class_scope:MADS.CreateTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::MADS::Tag* tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// -------------------------------------------------------------------

class Empty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MADS.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  virtual ~Empty();

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(nullptr);
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MADS.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MADS_2eproto);
    return ::descriptor_table_MADS_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MADS.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MADS_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Object

// int64 id = 1;
inline void Object::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Object::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Object::id() const {
  // @@protoc_insertion_point(field_get:MADS.Object.id)
  return _internal_id();
}
inline void Object::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void Object::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MADS.Object.id)
}

// string URI = 2;
inline void Object::clear_uri() {
  uri_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Object::uri() const {
  // @@protoc_insertion_point(field_get:MADS.Object.URI)
  return _internal_uri();
}
inline void Object::set_uri(const std::string& value) {
  _internal_set_uri(value);
  // @@protoc_insertion_point(field_set:MADS.Object.URI)
}
inline std::string* Object::mutable_uri() {
  // @@protoc_insertion_point(field_mutable:MADS.Object.URI)
  return _internal_mutable_uri();
}
inline const std::string& Object::_internal_uri() const {
  return uri_.Get();
}
inline void Object::_internal_set_uri(const std::string& value) {
  
  uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Object::set_uri(std::string&& value) {
  
  uri_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.Object.URI)
}
inline void Object::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.Object.URI)
}
inline void Object::set_uri(const char* value,
    size_t size) {
  
  uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.Object.URI)
}
inline std::string* Object::_internal_mutable_uri() {
  
  return uri_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Object::release_uri() {
  // @@protoc_insertion_point(field_release:MADS.Object.URI)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Object::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.Object.URI)
}

// string thumbnail = 3;
inline void Object::clear_thumbnail() {
  thumbnail_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Object::thumbnail() const {
  // @@protoc_insertion_point(field_get:MADS.Object.thumbnail)
  return _internal_thumbnail();
}
inline void Object::set_thumbnail(const std::string& value) {
  _internal_set_thumbnail(value);
  // @@protoc_insertion_point(field_set:MADS.Object.thumbnail)
}
inline std::string* Object::mutable_thumbnail() {
  // @@protoc_insertion_point(field_mutable:MADS.Object.thumbnail)
  return _internal_mutable_thumbnail();
}
inline const std::string& Object::_internal_thumbnail() const {
  return thumbnail_.Get();
}
inline void Object::_internal_set_thumbnail(const std::string& value) {
  
  thumbnail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Object::set_thumbnail(std::string&& value) {
  
  thumbnail_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.Object.thumbnail)
}
inline void Object::set_thumbnail(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  thumbnail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.Object.thumbnail)
}
inline void Object::set_thumbnail(const char* value,
    size_t size) {
  
  thumbnail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.Object.thumbnail)
}
inline std::string* Object::_internal_mutable_thumbnail() {
  
  return thumbnail_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Object::release_thumbnail() {
  // @@protoc_insertion_point(field_release:MADS.Object.thumbnail)
  return thumbnail_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Object::set_allocated_thumbnail(std::string* thumbnail) {
  if (thumbnail != nullptr) {
    
  } else {
    
  }
  thumbnail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), thumbnail,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.Object.thumbnail)
}

// string fileType = 4;
inline void Object::clear_filetype() {
  filetype_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Object::filetype() const {
  // @@protoc_insertion_point(field_get:MADS.Object.fileType)
  return _internal_filetype();
}
inline void Object::set_filetype(const std::string& value) {
  _internal_set_filetype(value);
  // @@protoc_insertion_point(field_set:MADS.Object.fileType)
}
inline std::string* Object::mutable_filetype() {
  // @@protoc_insertion_point(field_mutable:MADS.Object.fileType)
  return _internal_mutable_filetype();
}
inline const std::string& Object::_internal_filetype() const {
  return filetype_.Get();
}
inline void Object::_internal_set_filetype(const std::string& value) {
  
  filetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Object::set_filetype(std::string&& value) {
  
  filetype_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.Object.fileType)
}
inline void Object::set_filetype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.Object.fileType)
}
inline void Object::set_filetype(const char* value,
    size_t size) {
  
  filetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.Object.fileType)
}
inline std::string* Object::_internal_mutable_filetype() {
  
  return filetype_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Object::release_filetype() {
  // @@protoc_insertion_point(field_release:MADS.Object.fileType)
  return filetype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Object::set_allocated_filetype(std::string* filetype) {
  if (filetype != nullptr) {
    
  } else {
    
  }
  filetype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filetype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.Object.fileType)
}

// -------------------------------------------------------------------

// GetObjectRequest

// int64 id = 1;
inline void GetObjectRequest::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetObjectRequest::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetObjectRequest::id() const {
  // @@protoc_insertion_point(field_get:MADS.GetObjectRequest.id)
  return _internal_id();
}
inline void GetObjectRequest::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void GetObjectRequest::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MADS.GetObjectRequest.id)
}

// -------------------------------------------------------------------

// GetObjectResponse

// .MADS.Object object = 1;
inline bool GetObjectResponse::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool GetObjectResponse::has_object() const {
  return _internal_has_object();
}
inline void GetObjectResponse::clear_object() {
  if (GetArena() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::MADS::Object& GetObjectResponse::_internal_object() const {
  const ::MADS::Object* p = object_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MADS::Object*>(
      &::MADS::_Object_default_instance_);
}
inline const ::MADS::Object& GetObjectResponse::object() const {
  // @@protoc_insertion_point(field_get:MADS.GetObjectResponse.object)
  return _internal_object();
}
inline void GetObjectResponse::unsafe_arena_set_allocated_object(
    ::MADS::Object* object) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.GetObjectResponse.object)
}
inline ::MADS::Object* GetObjectResponse::release_object() {
  
  ::MADS::Object* temp = object_;
  object_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MADS::Object* GetObjectResponse::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:MADS.GetObjectResponse.object)
  
  ::MADS::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::MADS::Object* GetObjectResponse::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::MADS::Object>(GetArena());
    object_ = p;
  }
  return object_;
}
inline ::MADS::Object* GetObjectResponse::mutable_object() {
  // @@protoc_insertion_point(field_mutable:MADS.GetObjectResponse.object)
  return _internal_mutable_object();
}
inline void GetObjectResponse::set_allocated_object(::MADS::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:MADS.GetObjectResponse.object)
}

// -------------------------------------------------------------------

// CreateObjectRequest

// string URI = 1;
inline void CreateObjectRequest::clear_uri() {
  uri_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CreateObjectRequest::uri() const {
  // @@protoc_insertion_point(field_get:MADS.CreateObjectRequest.URI)
  return _internal_uri();
}
inline void CreateObjectRequest::set_uri(const std::string& value) {
  _internal_set_uri(value);
  // @@protoc_insertion_point(field_set:MADS.CreateObjectRequest.URI)
}
inline std::string* CreateObjectRequest::mutable_uri() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateObjectRequest.URI)
  return _internal_mutable_uri();
}
inline const std::string& CreateObjectRequest::_internal_uri() const {
  return uri_.Get();
}
inline void CreateObjectRequest::_internal_set_uri(const std::string& value) {
  
  uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreateObjectRequest::set_uri(std::string&& value) {
  
  uri_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.CreateObjectRequest.URI)
}
inline void CreateObjectRequest::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.CreateObjectRequest.URI)
}
inline void CreateObjectRequest::set_uri(const char* value,
    size_t size) {
  
  uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.CreateObjectRequest.URI)
}
inline std::string* CreateObjectRequest::_internal_mutable_uri() {
  
  return uri_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreateObjectRequest::release_uri() {
  // @@protoc_insertion_point(field_release:MADS.CreateObjectRequest.URI)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateObjectRequest::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.CreateObjectRequest.URI)
}

// string fileType = 3;
inline void CreateObjectRequest::clear_filetype() {
  filetype_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CreateObjectRequest::filetype() const {
  // @@protoc_insertion_point(field_get:MADS.CreateObjectRequest.fileType)
  return _internal_filetype();
}
inline void CreateObjectRequest::set_filetype(const std::string& value) {
  _internal_set_filetype(value);
  // @@protoc_insertion_point(field_set:MADS.CreateObjectRequest.fileType)
}
inline std::string* CreateObjectRequest::mutable_filetype() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateObjectRequest.fileType)
  return _internal_mutable_filetype();
}
inline const std::string& CreateObjectRequest::_internal_filetype() const {
  return filetype_.Get();
}
inline void CreateObjectRequest::_internal_set_filetype(const std::string& value) {
  
  filetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreateObjectRequest::set_filetype(std::string&& value) {
  
  filetype_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.CreateObjectRequest.fileType)
}
inline void CreateObjectRequest::set_filetype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.CreateObjectRequest.fileType)
}
inline void CreateObjectRequest::set_filetype(const char* value,
    size_t size) {
  
  filetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.CreateObjectRequest.fileType)
}
inline std::string* CreateObjectRequest::_internal_mutable_filetype() {
  
  return filetype_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreateObjectRequest::release_filetype() {
  // @@protoc_insertion_point(field_release:MADS.CreateObjectRequest.fileType)
  return filetype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateObjectRequest::set_allocated_filetype(std::string* filetype) {
  if (filetype != nullptr) {
    
  } else {
    
  }
  filetype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filetype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.CreateObjectRequest.fileType)
}

// -------------------------------------------------------------------

// CreateObjectResponse

// .MADS.Object object = 1;
inline bool CreateObjectResponse::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool CreateObjectResponse::has_object() const {
  return _internal_has_object();
}
inline void CreateObjectResponse::clear_object() {
  if (GetArena() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::MADS::Object& CreateObjectResponse::_internal_object() const {
  const ::MADS::Object* p = object_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MADS::Object*>(
      &::MADS::_Object_default_instance_);
}
inline const ::MADS::Object& CreateObjectResponse::object() const {
  // @@protoc_insertion_point(field_get:MADS.CreateObjectResponse.object)
  return _internal_object();
}
inline void CreateObjectResponse::unsafe_arena_set_allocated_object(
    ::MADS::Object* object) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.CreateObjectResponse.object)
}
inline ::MADS::Object* CreateObjectResponse::release_object() {
  
  ::MADS::Object* temp = object_;
  object_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MADS::Object* CreateObjectResponse::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:MADS.CreateObjectResponse.object)
  
  ::MADS::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::MADS::Object* CreateObjectResponse::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::MADS::Object>(GetArena());
    object_ = p;
  }
  return object_;
}
inline ::MADS::Object* CreateObjectResponse::mutable_object() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateObjectResponse.object)
  return _internal_mutable_object();
}
inline void CreateObjectResponse::set_allocated_object(::MADS::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:MADS.CreateObjectResponse.object)
}

// -------------------------------------------------------------------

// TagSet

// int64 id = 1;
inline void TagSet::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagSet::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagSet::id() const {
  // @@protoc_insertion_point(field_get:MADS.TagSet.id)
  return _internal_id();
}
inline void TagSet::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void TagSet::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MADS.TagSet.id)
}

// string name = 2;
inline void TagSet::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TagSet::name() const {
  // @@protoc_insertion_point(field_get:MADS.TagSet.name)
  return _internal_name();
}
inline void TagSet::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:MADS.TagSet.name)
}
inline std::string* TagSet::mutable_name() {
  // @@protoc_insertion_point(field_mutable:MADS.TagSet.name)
  return _internal_mutable_name();
}
inline const std::string& TagSet::_internal_name() const {
  return name_.Get();
}
inline void TagSet::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TagSet::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.TagSet.name)
}
inline void TagSet::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.TagSet.name)
}
inline void TagSet::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.TagSet.name)
}
inline std::string* TagSet::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TagSet::release_name() {
  // @@protoc_insertion_point(field_release:MADS.TagSet.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TagSet::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.TagSet.name)
}

// string description = 3;
inline void TagSet::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TagSet::description() const {
  // @@protoc_insertion_point(field_get:MADS.TagSet.description)
  return _internal_description();
}
inline void TagSet::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:MADS.TagSet.description)
}
inline std::string* TagSet::mutable_description() {
  // @@protoc_insertion_point(field_mutable:MADS.TagSet.description)
  return _internal_mutable_description();
}
inline const std::string& TagSet::_internal_description() const {
  return description_.Get();
}
inline void TagSet::_internal_set_description(const std::string& value) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TagSet::set_description(std::string&& value) {
  
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.TagSet.description)
}
inline void TagSet::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.TagSet.description)
}
inline void TagSet::set_description(const char* value,
    size_t size) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.TagSet.description)
}
inline std::string* TagSet::_internal_mutable_description() {
  
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TagSet::release_description() {
  // @@protoc_insertion_point(field_release:MADS.TagSet.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TagSet::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.TagSet.description)
}

// .MADS.TagSetType type = 4;
inline void TagSet::clear_type() {
  type_ = 0;
}
inline ::MADS::TagSetType TagSet::_internal_type() const {
  return static_cast< ::MADS::TagSetType >(type_);
}
inline ::MADS::TagSetType TagSet::type() const {
  // @@protoc_insertion_point(field_get:MADS.TagSet.type)
  return _internal_type();
}
inline void TagSet::_internal_set_type(::MADS::TagSetType value) {
  
  type_ = value;
}
inline void TagSet::set_type(::MADS::TagSetType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MADS.TagSet.type)
}

// int64 accessId = 5;
inline void TagSet::clear_accessid() {
  accessid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagSet::_internal_accessid() const {
  return accessid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagSet::accessid() const {
  // @@protoc_insertion_point(field_get:MADS.TagSet.accessId)
  return _internal_accessid();
}
inline void TagSet::_internal_set_accessid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  accessid_ = value;
}
inline void TagSet::set_accessid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_accessid(value);
  // @@protoc_insertion_point(field_set:MADS.TagSet.accessId)
}

// -------------------------------------------------------------------

// GetTagSetsRequest

// -------------------------------------------------------------------

// GetTagSetsResponse

// repeated .MADS.TagSet tagsets = 1;
inline int GetTagSetsResponse::_internal_tagsets_size() const {
  return tagsets_.size();
}
inline int GetTagSetsResponse::tagsets_size() const {
  return _internal_tagsets_size();
}
inline void GetTagSetsResponse::clear_tagsets() {
  tagsets_.Clear();
}
inline ::MADS::TagSet* GetTagSetsResponse::mutable_tagsets(int index) {
  // @@protoc_insertion_point(field_mutable:MADS.GetTagSetsResponse.tagsets)
  return tagsets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::TagSet >*
GetTagSetsResponse::mutable_tagsets() {
  // @@protoc_insertion_point(field_mutable_list:MADS.GetTagSetsResponse.tagsets)
  return &tagsets_;
}
inline const ::MADS::TagSet& GetTagSetsResponse::_internal_tagsets(int index) const {
  return tagsets_.Get(index);
}
inline const ::MADS::TagSet& GetTagSetsResponse::tagsets(int index) const {
  // @@protoc_insertion_point(field_get:MADS.GetTagSetsResponse.tagsets)
  return _internal_tagsets(index);
}
inline ::MADS::TagSet* GetTagSetsResponse::_internal_add_tagsets() {
  return tagsets_.Add();
}
inline ::MADS::TagSet* GetTagSetsResponse::add_tagsets() {
  // @@protoc_insertion_point(field_add:MADS.GetTagSetsResponse.tagsets)
  return _internal_add_tagsets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::TagSet >&
GetTagSetsResponse::tagsets() const {
  // @@protoc_insertion_point(field_list:MADS.GetTagSetsResponse.tagsets)
  return tagsets_;
}

// -------------------------------------------------------------------

// GetTagSetRequest

// int64 id = 1;
inline void GetTagSetRequest::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTagSetRequest::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTagSetRequest::id() const {
  // @@protoc_insertion_point(field_get:MADS.GetTagSetRequest.id)
  return _internal_id();
}
inline void GetTagSetRequest::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void GetTagSetRequest::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MADS.GetTagSetRequest.id)
}

// -------------------------------------------------------------------

// GetTagSetResponse

// .MADS.TagSet tagset = 1;
inline bool GetTagSetResponse::_internal_has_tagset() const {
  return this != internal_default_instance() && tagset_ != nullptr;
}
inline bool GetTagSetResponse::has_tagset() const {
  return _internal_has_tagset();
}
inline void GetTagSetResponse::clear_tagset() {
  if (GetArena() == nullptr && tagset_ != nullptr) {
    delete tagset_;
  }
  tagset_ = nullptr;
}
inline const ::MADS::TagSet& GetTagSetResponse::_internal_tagset() const {
  const ::MADS::TagSet* p = tagset_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MADS::TagSet*>(
      &::MADS::_TagSet_default_instance_);
}
inline const ::MADS::TagSet& GetTagSetResponse::tagset() const {
  // @@protoc_insertion_point(field_get:MADS.GetTagSetResponse.tagset)
  return _internal_tagset();
}
inline void GetTagSetResponse::unsafe_arena_set_allocated_tagset(
    ::MADS::TagSet* tagset) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tagset_);
  }
  tagset_ = tagset;
  if (tagset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.GetTagSetResponse.tagset)
}
inline ::MADS::TagSet* GetTagSetResponse::release_tagset() {
  
  ::MADS::TagSet* temp = tagset_;
  tagset_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MADS::TagSet* GetTagSetResponse::unsafe_arena_release_tagset() {
  // @@protoc_insertion_point(field_release:MADS.GetTagSetResponse.tagset)
  
  ::MADS::TagSet* temp = tagset_;
  tagset_ = nullptr;
  return temp;
}
inline ::MADS::TagSet* GetTagSetResponse::_internal_mutable_tagset() {
  
  if (tagset_ == nullptr) {
    auto* p = CreateMaybeMessage<::MADS::TagSet>(GetArena());
    tagset_ = p;
  }
  return tagset_;
}
inline ::MADS::TagSet* GetTagSetResponse::mutable_tagset() {
  // @@protoc_insertion_point(field_mutable:MADS.GetTagSetResponse.tagset)
  return _internal_mutable_tagset();
}
inline void GetTagSetResponse::set_allocated_tagset(::MADS::TagSet* tagset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tagset_;
  }
  if (tagset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tagset);
    if (message_arena != submessage_arena) {
      tagset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tagset, submessage_arena);
    }
    
  } else {
    
  }
  tagset_ = tagset;
  // @@protoc_insertion_point(field_set_allocated:MADS.GetTagSetResponse.tagset)
}

// -------------------------------------------------------------------

// CreateTagSetRequest

// string name = 1;
inline void CreateTagSetRequest::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CreateTagSetRequest::name() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagSetRequest.name)
  return _internal_name();
}
inline void CreateTagSetRequest::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:MADS.CreateTagSetRequest.name)
}
inline std::string* CreateTagSetRequest::mutable_name() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateTagSetRequest.name)
  return _internal_mutable_name();
}
inline const std::string& CreateTagSetRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateTagSetRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreateTagSetRequest::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.CreateTagSetRequest.name)
}
inline void CreateTagSetRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.CreateTagSetRequest.name)
}
inline void CreateTagSetRequest::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.CreateTagSetRequest.name)
}
inline std::string* CreateTagSetRequest::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreateTagSetRequest::release_name() {
  // @@protoc_insertion_point(field_release:MADS.CreateTagSetRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateTagSetRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.CreateTagSetRequest.name)
}

// string description = 2;
inline void CreateTagSetRequest::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CreateTagSetRequest::description() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagSetRequest.description)
  return _internal_description();
}
inline void CreateTagSetRequest::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:MADS.CreateTagSetRequest.description)
}
inline std::string* CreateTagSetRequest::mutable_description() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateTagSetRequest.description)
  return _internal_mutable_description();
}
inline const std::string& CreateTagSetRequest::_internal_description() const {
  return description_.Get();
}
inline void CreateTagSetRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreateTagSetRequest::set_description(std::string&& value) {
  
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.CreateTagSetRequest.description)
}
inline void CreateTagSetRequest::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.CreateTagSetRequest.description)
}
inline void CreateTagSetRequest::set_description(const char* value,
    size_t size) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.CreateTagSetRequest.description)
}
inline std::string* CreateTagSetRequest::_internal_mutable_description() {
  
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreateTagSetRequest::release_description() {
  // @@protoc_insertion_point(field_release:MADS.CreateTagSetRequest.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateTagSetRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.CreateTagSetRequest.description)
}

// .MADS.TagSetType type = 3;
inline void CreateTagSetRequest::clear_type() {
  type_ = 0;
}
inline ::MADS::TagSetType CreateTagSetRequest::_internal_type() const {
  return static_cast< ::MADS::TagSetType >(type_);
}
inline ::MADS::TagSetType CreateTagSetRequest::type() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagSetRequest.type)
  return _internal_type();
}
inline void CreateTagSetRequest::_internal_set_type(::MADS::TagSetType value) {
  
  type_ = value;
}
inline void CreateTagSetRequest::set_type(::MADS::TagSetType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MADS.CreateTagSetRequest.type)
}

// -------------------------------------------------------------------

// CreateTagSetResponse

// .MADS.TagSet tagset = 1;
inline bool CreateTagSetResponse::_internal_has_tagset() const {
  return this != internal_default_instance() && tagset_ != nullptr;
}
inline bool CreateTagSetResponse::has_tagset() const {
  return _internal_has_tagset();
}
inline void CreateTagSetResponse::clear_tagset() {
  if (GetArena() == nullptr && tagset_ != nullptr) {
    delete tagset_;
  }
  tagset_ = nullptr;
}
inline const ::MADS::TagSet& CreateTagSetResponse::_internal_tagset() const {
  const ::MADS::TagSet* p = tagset_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MADS::TagSet*>(
      &::MADS::_TagSet_default_instance_);
}
inline const ::MADS::TagSet& CreateTagSetResponse::tagset() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagSetResponse.tagset)
  return _internal_tagset();
}
inline void CreateTagSetResponse::unsafe_arena_set_allocated_tagset(
    ::MADS::TagSet* tagset) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tagset_);
  }
  tagset_ = tagset;
  if (tagset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.CreateTagSetResponse.tagset)
}
inline ::MADS::TagSet* CreateTagSetResponse::release_tagset() {
  
  ::MADS::TagSet* temp = tagset_;
  tagset_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MADS::TagSet* CreateTagSetResponse::unsafe_arena_release_tagset() {
  // @@protoc_insertion_point(field_release:MADS.CreateTagSetResponse.tagset)
  
  ::MADS::TagSet* temp = tagset_;
  tagset_ = nullptr;
  return temp;
}
inline ::MADS::TagSet* CreateTagSetResponse::_internal_mutable_tagset() {
  
  if (tagset_ == nullptr) {
    auto* p = CreateMaybeMessage<::MADS::TagSet>(GetArena());
    tagset_ = p;
  }
  return tagset_;
}
inline ::MADS::TagSet* CreateTagSetResponse::mutable_tagset() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateTagSetResponse.tagset)
  return _internal_mutable_tagset();
}
inline void CreateTagSetResponse::set_allocated_tagset(::MADS::TagSet* tagset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tagset_;
  }
  if (tagset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tagset);
    if (message_arena != submessage_arena) {
      tagset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tagset, submessage_arena);
    }
    
  } else {
    
  }
  tagset_ = tagset;
  // @@protoc_insertion_point(field_set_allocated:MADS.CreateTagSetResponse.tagset)
}

// -------------------------------------------------------------------

// AlphanumericalValue

// string value = 1;
inline void AlphanumericalValue::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AlphanumericalValue::value() const {
  // @@protoc_insertion_point(field_get:MADS.AlphanumericalValue.value)
  return _internal_value();
}
inline void AlphanumericalValue::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:MADS.AlphanumericalValue.value)
}
inline std::string* AlphanumericalValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:MADS.AlphanumericalValue.value)
  return _internal_mutable_value();
}
inline const std::string& AlphanumericalValue::_internal_value() const {
  return value_.Get();
}
inline void AlphanumericalValue::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AlphanumericalValue::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.AlphanumericalValue.value)
}
inline void AlphanumericalValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.AlphanumericalValue.value)
}
inline void AlphanumericalValue::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.AlphanumericalValue.value)
}
inline std::string* AlphanumericalValue::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AlphanumericalValue::release_value() {
  // @@protoc_insertion_point(field_release:MADS.AlphanumericalValue.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AlphanumericalValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.AlphanumericalValue.value)
}

// -------------------------------------------------------------------

// NumericalValue

// string value = 1;
inline void NumericalValue::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NumericalValue::value() const {
  // @@protoc_insertion_point(field_get:MADS.NumericalValue.value)
  return _internal_value();
}
inline void NumericalValue::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:MADS.NumericalValue.value)
}
inline std::string* NumericalValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:MADS.NumericalValue.value)
  return _internal_mutable_value();
}
inline const std::string& NumericalValue::_internal_value() const {
  return value_.Get();
}
inline void NumericalValue::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NumericalValue::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.NumericalValue.value)
}
inline void NumericalValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.NumericalValue.value)
}
inline void NumericalValue::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.NumericalValue.value)
}
inline std::string* NumericalValue::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NumericalValue::release_value() {
  // @@protoc_insertion_point(field_release:MADS.NumericalValue.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NumericalValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.NumericalValue.value)
}

// -------------------------------------------------------------------

// DateValue

// string value = 1;
inline void DateValue::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DateValue::value() const {
  // @@protoc_insertion_point(field_get:MADS.DateValue.value)
  return _internal_value();
}
inline void DateValue::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:MADS.DateValue.value)
}
inline std::string* DateValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:MADS.DateValue.value)
  return _internal_mutable_value();
}
inline const std::string& DateValue::_internal_value() const {
  return value_.Get();
}
inline void DateValue::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DateValue::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.DateValue.value)
}
inline void DateValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.DateValue.value)
}
inline void DateValue::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.DateValue.value)
}
inline std::string* DateValue::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DateValue::release_value() {
  // @@protoc_insertion_point(field_release:MADS.DateValue.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DateValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.DateValue.value)
}

// -------------------------------------------------------------------

// TimeValue

// string value = 1;
inline void TimeValue::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TimeValue::value() const {
  // @@protoc_insertion_point(field_get:MADS.TimeValue.value)
  return _internal_value();
}
inline void TimeValue::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:MADS.TimeValue.value)
}
inline std::string* TimeValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:MADS.TimeValue.value)
  return _internal_mutable_value();
}
inline const std::string& TimeValue::_internal_value() const {
  return value_.Get();
}
inline void TimeValue::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TimeValue::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MADS.TimeValue.value)
}
inline void TimeValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MADS.TimeValue.value)
}
inline void TimeValue::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MADS.TimeValue.value)
}
inline std::string* TimeValue::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TimeValue::release_value() {
  // @@protoc_insertion_point(field_release:MADS.TimeValue.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TimeValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MADS.TimeValue.value)
}

// -------------------------------------------------------------------

// RGBValue

// int64 red = 1;
inline void RGBValue::clear_red() {
  red_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RGBValue::_internal_red() const {
  return red_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RGBValue::red() const {
  // @@protoc_insertion_point(field_get:MADS.RGBValue.red)
  return _internal_red();
}
inline void RGBValue::_internal_set_red(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  red_ = value;
}
inline void RGBValue::set_red(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_red(value);
  // @@protoc_insertion_point(field_set:MADS.RGBValue.red)
}

// int64 green = 2;
inline void RGBValue::clear_green() {
  green_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RGBValue::_internal_green() const {
  return green_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RGBValue::green() const {
  // @@protoc_insertion_point(field_get:MADS.RGBValue.green)
  return _internal_green();
}
inline void RGBValue::_internal_set_green(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  green_ = value;
}
inline void RGBValue::set_green(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_green(value);
  // @@protoc_insertion_point(field_set:MADS.RGBValue.green)
}

// int64 blue = 3;
inline void RGBValue::clear_blue() {
  blue_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RGBValue::_internal_blue() const {
  return blue_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RGBValue::blue() const {
  // @@protoc_insertion_point(field_get:MADS.RGBValue.blue)
  return _internal_blue();
}
inline void RGBValue::_internal_set_blue(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  blue_ = value;
}
inline void RGBValue::set_blue(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_blue(value);
  // @@protoc_insertion_point(field_set:MADS.RGBValue.blue)
}

// -------------------------------------------------------------------

// Tag

// int64 id = 1;
inline void Tag::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Tag::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Tag::id() const {
  // @@protoc_insertion_point(field_get:MADS.Tag.id)
  return _internal_id();
}
inline void Tag::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void Tag::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MADS.Tag.id)
}

// int64 tagSetId = 2;
inline void Tag::clear_tagsetid() {
  tagsetid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Tag::_internal_tagsetid() const {
  return tagsetid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Tag::tagsetid() const {
  // @@protoc_insertion_point(field_get:MADS.Tag.tagSetId)
  return _internal_tagsetid();
}
inline void Tag::_internal_set_tagsetid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tagsetid_ = value;
}
inline void Tag::set_tagsetid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tagsetid(value);
  // @@protoc_insertion_point(field_set:MADS.Tag.tagSetId)
}

// int64 typeId = 3;
inline void Tag::clear_typeid_() {
  typeid__ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Tag::_internal_typeid_() const {
  return typeid__;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Tag::typeid_() const {
  // @@protoc_insertion_point(field_get:MADS.Tag.typeId)
  return _internal_typeid_();
}
inline void Tag::_internal_set_typeid_(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  typeid__ = value;
}
inline void Tag::set_typeid_(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_typeid_(value);
  // @@protoc_insertion_point(field_set:MADS.Tag.typeId)
}

// .MADS.AlphanumericalValue alphanumerical = 4;
inline bool Tag::_internal_has_alphanumerical() const {
  return value_case() == kAlphanumerical;
}
inline bool Tag::has_alphanumerical() const {
  return _internal_has_alphanumerical();
}
inline void Tag::set_has_alphanumerical() {
  _oneof_case_[0] = kAlphanumerical;
}
inline void Tag::clear_alphanumerical() {
  if (_internal_has_alphanumerical()) {
    if (GetArena() == nullptr) {
      delete value_.alphanumerical_;
    }
    clear_has_value();
  }
}
inline ::MADS::AlphanumericalValue* Tag::release_alphanumerical() {
  // @@protoc_insertion_point(field_release:MADS.Tag.alphanumerical)
  if (_internal_has_alphanumerical()) {
    clear_has_value();
      ::MADS::AlphanumericalValue* temp = value_.alphanumerical_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.alphanumerical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::AlphanumericalValue& Tag::_internal_alphanumerical() const {
  return _internal_has_alphanumerical()
      ? *value_.alphanumerical_
      : *reinterpret_cast< ::MADS::AlphanumericalValue*>(&::MADS::_AlphanumericalValue_default_instance_);
}
inline const ::MADS::AlphanumericalValue& Tag::alphanumerical() const {
  // @@protoc_insertion_point(field_get:MADS.Tag.alphanumerical)
  return _internal_alphanumerical();
}
inline ::MADS::AlphanumericalValue* Tag::unsafe_arena_release_alphanumerical() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.Tag.alphanumerical)
  if (_internal_has_alphanumerical()) {
    clear_has_value();
    ::MADS::AlphanumericalValue* temp = value_.alphanumerical_;
    value_.alphanumerical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Tag::unsafe_arena_set_allocated_alphanumerical(::MADS::AlphanumericalValue* alphanumerical) {
  clear_value();
  if (alphanumerical) {
    set_has_alphanumerical();
    value_.alphanumerical_ = alphanumerical;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.Tag.alphanumerical)
}
inline ::MADS::AlphanumericalValue* Tag::_internal_mutable_alphanumerical() {
  if (!_internal_has_alphanumerical()) {
    clear_value();
    set_has_alphanumerical();
    value_.alphanumerical_ = CreateMaybeMessage< ::MADS::AlphanumericalValue >(GetArena());
  }
  return value_.alphanumerical_;
}
inline ::MADS::AlphanumericalValue* Tag::mutable_alphanumerical() {
  // @@protoc_insertion_point(field_mutable:MADS.Tag.alphanumerical)
  return _internal_mutable_alphanumerical();
}

// .MADS.NumericalValue numerical = 5;
inline bool Tag::_internal_has_numerical() const {
  return value_case() == kNumerical;
}
inline bool Tag::has_numerical() const {
  return _internal_has_numerical();
}
inline void Tag::set_has_numerical() {
  _oneof_case_[0] = kNumerical;
}
inline void Tag::clear_numerical() {
  if (_internal_has_numerical()) {
    if (GetArena() == nullptr) {
      delete value_.numerical_;
    }
    clear_has_value();
  }
}
inline ::MADS::NumericalValue* Tag::release_numerical() {
  // @@protoc_insertion_point(field_release:MADS.Tag.numerical)
  if (_internal_has_numerical()) {
    clear_has_value();
      ::MADS::NumericalValue* temp = value_.numerical_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.numerical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::NumericalValue& Tag::_internal_numerical() const {
  return _internal_has_numerical()
      ? *value_.numerical_
      : *reinterpret_cast< ::MADS::NumericalValue*>(&::MADS::_NumericalValue_default_instance_);
}
inline const ::MADS::NumericalValue& Tag::numerical() const {
  // @@protoc_insertion_point(field_get:MADS.Tag.numerical)
  return _internal_numerical();
}
inline ::MADS::NumericalValue* Tag::unsafe_arena_release_numerical() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.Tag.numerical)
  if (_internal_has_numerical()) {
    clear_has_value();
    ::MADS::NumericalValue* temp = value_.numerical_;
    value_.numerical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Tag::unsafe_arena_set_allocated_numerical(::MADS::NumericalValue* numerical) {
  clear_value();
  if (numerical) {
    set_has_numerical();
    value_.numerical_ = numerical;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.Tag.numerical)
}
inline ::MADS::NumericalValue* Tag::_internal_mutable_numerical() {
  if (!_internal_has_numerical()) {
    clear_value();
    set_has_numerical();
    value_.numerical_ = CreateMaybeMessage< ::MADS::NumericalValue >(GetArena());
  }
  return value_.numerical_;
}
inline ::MADS::NumericalValue* Tag::mutable_numerical() {
  // @@protoc_insertion_point(field_mutable:MADS.Tag.numerical)
  return _internal_mutable_numerical();
}

// .MADS.DateValue date = 6;
inline bool Tag::_internal_has_date() const {
  return value_case() == kDate;
}
inline bool Tag::has_date() const {
  return _internal_has_date();
}
inline void Tag::set_has_date() {
  _oneof_case_[0] = kDate;
}
inline void Tag::clear_date() {
  if (_internal_has_date()) {
    if (GetArena() == nullptr) {
      delete value_.date_;
    }
    clear_has_value();
  }
}
inline ::MADS::DateValue* Tag::release_date() {
  // @@protoc_insertion_point(field_release:MADS.Tag.date)
  if (_internal_has_date()) {
    clear_has_value();
      ::MADS::DateValue* temp = value_.date_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::DateValue& Tag::_internal_date() const {
  return _internal_has_date()
      ? *value_.date_
      : *reinterpret_cast< ::MADS::DateValue*>(&::MADS::_DateValue_default_instance_);
}
inline const ::MADS::DateValue& Tag::date() const {
  // @@protoc_insertion_point(field_get:MADS.Tag.date)
  return _internal_date();
}
inline ::MADS::DateValue* Tag::unsafe_arena_release_date() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.Tag.date)
  if (_internal_has_date()) {
    clear_has_value();
    ::MADS::DateValue* temp = value_.date_;
    value_.date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Tag::unsafe_arena_set_allocated_date(::MADS::DateValue* date) {
  clear_value();
  if (date) {
    set_has_date();
    value_.date_ = date;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.Tag.date)
}
inline ::MADS::DateValue* Tag::_internal_mutable_date() {
  if (!_internal_has_date()) {
    clear_value();
    set_has_date();
    value_.date_ = CreateMaybeMessage< ::MADS::DateValue >(GetArena());
  }
  return value_.date_;
}
inline ::MADS::DateValue* Tag::mutable_date() {
  // @@protoc_insertion_point(field_mutable:MADS.Tag.date)
  return _internal_mutable_date();
}

// .MADS.TimeValue time = 7;
inline bool Tag::_internal_has_time() const {
  return value_case() == kTime;
}
inline bool Tag::has_time() const {
  return _internal_has_time();
}
inline void Tag::set_has_time() {
  _oneof_case_[0] = kTime;
}
inline void Tag::clear_time() {
  if (_internal_has_time()) {
    if (GetArena() == nullptr) {
      delete value_.time_;
    }
    clear_has_value();
  }
}
inline ::MADS::TimeValue* Tag::release_time() {
  // @@protoc_insertion_point(field_release:MADS.Tag.time)
  if (_internal_has_time()) {
    clear_has_value();
      ::MADS::TimeValue* temp = value_.time_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::TimeValue& Tag::_internal_time() const {
  return _internal_has_time()
      ? *value_.time_
      : *reinterpret_cast< ::MADS::TimeValue*>(&::MADS::_TimeValue_default_instance_);
}
inline const ::MADS::TimeValue& Tag::time() const {
  // @@protoc_insertion_point(field_get:MADS.Tag.time)
  return _internal_time();
}
inline ::MADS::TimeValue* Tag::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.Tag.time)
  if (_internal_has_time()) {
    clear_has_value();
    ::MADS::TimeValue* temp = value_.time_;
    value_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Tag::unsafe_arena_set_allocated_time(::MADS::TimeValue* time) {
  clear_value();
  if (time) {
    set_has_time();
    value_.time_ = time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.Tag.time)
}
inline ::MADS::TimeValue* Tag::_internal_mutable_time() {
  if (!_internal_has_time()) {
    clear_value();
    set_has_time();
    value_.time_ = CreateMaybeMessage< ::MADS::TimeValue >(GetArena());
  }
  return value_.time_;
}
inline ::MADS::TimeValue* Tag::mutable_time() {
  // @@protoc_insertion_point(field_mutable:MADS.Tag.time)
  return _internal_mutable_time();
}

// .MADS.RGBValue rgb = 8;
inline bool Tag::_internal_has_rgb() const {
  return value_case() == kRgb;
}
inline bool Tag::has_rgb() const {
  return _internal_has_rgb();
}
inline void Tag::set_has_rgb() {
  _oneof_case_[0] = kRgb;
}
inline void Tag::clear_rgb() {
  if (_internal_has_rgb()) {
    if (GetArena() == nullptr) {
      delete value_.rgb_;
    }
    clear_has_value();
  }
}
inline ::MADS::RGBValue* Tag::release_rgb() {
  // @@protoc_insertion_point(field_release:MADS.Tag.rgb)
  if (_internal_has_rgb()) {
    clear_has_value();
      ::MADS::RGBValue* temp = value_.rgb_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.rgb_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::RGBValue& Tag::_internal_rgb() const {
  return _internal_has_rgb()
      ? *value_.rgb_
      : *reinterpret_cast< ::MADS::RGBValue*>(&::MADS::_RGBValue_default_instance_);
}
inline const ::MADS::RGBValue& Tag::rgb() const {
  // @@protoc_insertion_point(field_get:MADS.Tag.rgb)
  return _internal_rgb();
}
inline ::MADS::RGBValue* Tag::unsafe_arena_release_rgb() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.Tag.rgb)
  if (_internal_has_rgb()) {
    clear_has_value();
    ::MADS::RGBValue* temp = value_.rgb_;
    value_.rgb_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Tag::unsafe_arena_set_allocated_rgb(::MADS::RGBValue* rgb) {
  clear_value();
  if (rgb) {
    set_has_rgb();
    value_.rgb_ = rgb;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.Tag.rgb)
}
inline ::MADS::RGBValue* Tag::_internal_mutable_rgb() {
  if (!_internal_has_rgb()) {
    clear_value();
    set_has_rgb();
    value_.rgb_ = CreateMaybeMessage< ::MADS::RGBValue >(GetArena());
  }
  return value_.rgb_;
}
inline ::MADS::RGBValue* Tag::mutable_rgb() {
  // @@protoc_insertion_point(field_mutable:MADS.Tag.rgb)
  return _internal_mutable_rgb();
}

inline bool Tag::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Tag::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Tag::ValueCase Tag::value_case() const {
  return Tag::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetTagsRequest

// -------------------------------------------------------------------

// GetTagsResponse

// repeated .MADS.Tag tags = 1;
inline int GetTagsResponse::_internal_tags_size() const {
  return tags_.size();
}
inline int GetTagsResponse::tags_size() const {
  return _internal_tags_size();
}
inline void GetTagsResponse::clear_tags() {
  tags_.Clear();
}
inline ::MADS::Tag* GetTagsResponse::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:MADS.GetTagsResponse.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::Tag >*
GetTagsResponse::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:MADS.GetTagsResponse.tags)
  return &tags_;
}
inline const ::MADS::Tag& GetTagsResponse::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::MADS::Tag& GetTagsResponse::tags(int index) const {
  // @@protoc_insertion_point(field_get:MADS.GetTagsResponse.tags)
  return _internal_tags(index);
}
inline ::MADS::Tag* GetTagsResponse::_internal_add_tags() {
  return tags_.Add();
}
inline ::MADS::Tag* GetTagsResponse::add_tags() {
  // @@protoc_insertion_point(field_add:MADS.GetTagsResponse.tags)
  return _internal_add_tags();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MADS::Tag >&
GetTagsResponse::tags() const {
  // @@protoc_insertion_point(field_list:MADS.GetTagsResponse.tags)
  return tags_;
}

// -------------------------------------------------------------------

// GetTagRequest

// int64 id = 1;
inline void GetTagRequest::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTagRequest::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTagRequest::id() const {
  // @@protoc_insertion_point(field_get:MADS.GetTagRequest.id)
  return _internal_id();
}
inline void GetTagRequest::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void GetTagRequest::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MADS.GetTagRequest.id)
}

// -------------------------------------------------------------------

// GetTagResponse

// .MADS.Tag tag = 1;
inline bool GetTagResponse::_internal_has_tag() const {
  return this != internal_default_instance() && tag_ != nullptr;
}
inline bool GetTagResponse::has_tag() const {
  return _internal_has_tag();
}
inline void GetTagResponse::clear_tag() {
  if (GetArena() == nullptr && tag_ != nullptr) {
    delete tag_;
  }
  tag_ = nullptr;
}
inline const ::MADS::Tag& GetTagResponse::_internal_tag() const {
  const ::MADS::Tag* p = tag_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MADS::Tag*>(
      &::MADS::_Tag_default_instance_);
}
inline const ::MADS::Tag& GetTagResponse::tag() const {
  // @@protoc_insertion_point(field_get:MADS.GetTagResponse.tag)
  return _internal_tag();
}
inline void GetTagResponse::unsafe_arena_set_allocated_tag(
    ::MADS::Tag* tag) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tag_);
  }
  tag_ = tag;
  if (tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.GetTagResponse.tag)
}
inline ::MADS::Tag* GetTagResponse::release_tag() {
  
  ::MADS::Tag* temp = tag_;
  tag_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MADS::Tag* GetTagResponse::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_release:MADS.GetTagResponse.tag)
  
  ::MADS::Tag* temp = tag_;
  tag_ = nullptr;
  return temp;
}
inline ::MADS::Tag* GetTagResponse::_internal_mutable_tag() {
  
  if (tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::MADS::Tag>(GetArena());
    tag_ = p;
  }
  return tag_;
}
inline ::MADS::Tag* GetTagResponse::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:MADS.GetTagResponse.tag)
  return _internal_mutable_tag();
}
inline void GetTagResponse::set_allocated_tag(::MADS::Tag* tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tag_;
  }
  if (tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tag);
    if (message_arena != submessage_arena) {
      tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    
  } else {
    
  }
  tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:MADS.GetTagResponse.tag)
}

// -------------------------------------------------------------------

// CreateTagRequest

// int64 tagSetId = 1;
inline void CreateTagRequest::clear_tagsetid() {
  tagsetid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateTagRequest::_internal_tagsetid() const {
  return tagsetid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateTagRequest::tagsetid() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagRequest.tagSetId)
  return _internal_tagsetid();
}
inline void CreateTagRequest::_internal_set_tagsetid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tagsetid_ = value;
}
inline void CreateTagRequest::set_tagsetid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tagsetid(value);
  // @@protoc_insertion_point(field_set:MADS.CreateTagRequest.tagSetId)
}

// .MADS.AlphanumericalValue alphanumerical = 4;
inline bool CreateTagRequest::_internal_has_alphanumerical() const {
  return value_case() == kAlphanumerical;
}
inline bool CreateTagRequest::has_alphanumerical() const {
  return _internal_has_alphanumerical();
}
inline void CreateTagRequest::set_has_alphanumerical() {
  _oneof_case_[0] = kAlphanumerical;
}
inline void CreateTagRequest::clear_alphanumerical() {
  if (_internal_has_alphanumerical()) {
    if (GetArena() == nullptr) {
      delete value_.alphanumerical_;
    }
    clear_has_value();
  }
}
inline ::MADS::AlphanumericalValue* CreateTagRequest::release_alphanumerical() {
  // @@protoc_insertion_point(field_release:MADS.CreateTagRequest.alphanumerical)
  if (_internal_has_alphanumerical()) {
    clear_has_value();
      ::MADS::AlphanumericalValue* temp = value_.alphanumerical_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.alphanumerical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::AlphanumericalValue& CreateTagRequest::_internal_alphanumerical() const {
  return _internal_has_alphanumerical()
      ? *value_.alphanumerical_
      : *reinterpret_cast< ::MADS::AlphanumericalValue*>(&::MADS::_AlphanumericalValue_default_instance_);
}
inline const ::MADS::AlphanumericalValue& CreateTagRequest::alphanumerical() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagRequest.alphanumerical)
  return _internal_alphanumerical();
}
inline ::MADS::AlphanumericalValue* CreateTagRequest::unsafe_arena_release_alphanumerical() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.CreateTagRequest.alphanumerical)
  if (_internal_has_alphanumerical()) {
    clear_has_value();
    ::MADS::AlphanumericalValue* temp = value_.alphanumerical_;
    value_.alphanumerical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateTagRequest::unsafe_arena_set_allocated_alphanumerical(::MADS::AlphanumericalValue* alphanumerical) {
  clear_value();
  if (alphanumerical) {
    set_has_alphanumerical();
    value_.alphanumerical_ = alphanumerical;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.CreateTagRequest.alphanumerical)
}
inline ::MADS::AlphanumericalValue* CreateTagRequest::_internal_mutable_alphanumerical() {
  if (!_internal_has_alphanumerical()) {
    clear_value();
    set_has_alphanumerical();
    value_.alphanumerical_ = CreateMaybeMessage< ::MADS::AlphanumericalValue >(GetArena());
  }
  return value_.alphanumerical_;
}
inline ::MADS::AlphanumericalValue* CreateTagRequest::mutable_alphanumerical() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateTagRequest.alphanumerical)
  return _internal_mutable_alphanumerical();
}

// .MADS.NumericalValue numerical = 5;
inline bool CreateTagRequest::_internal_has_numerical() const {
  return value_case() == kNumerical;
}
inline bool CreateTagRequest::has_numerical() const {
  return _internal_has_numerical();
}
inline void CreateTagRequest::set_has_numerical() {
  _oneof_case_[0] = kNumerical;
}
inline void CreateTagRequest::clear_numerical() {
  if (_internal_has_numerical()) {
    if (GetArena() == nullptr) {
      delete value_.numerical_;
    }
    clear_has_value();
  }
}
inline ::MADS::NumericalValue* CreateTagRequest::release_numerical() {
  // @@protoc_insertion_point(field_release:MADS.CreateTagRequest.numerical)
  if (_internal_has_numerical()) {
    clear_has_value();
      ::MADS::NumericalValue* temp = value_.numerical_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.numerical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::NumericalValue& CreateTagRequest::_internal_numerical() const {
  return _internal_has_numerical()
      ? *value_.numerical_
      : *reinterpret_cast< ::MADS::NumericalValue*>(&::MADS::_NumericalValue_default_instance_);
}
inline const ::MADS::NumericalValue& CreateTagRequest::numerical() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagRequest.numerical)
  return _internal_numerical();
}
inline ::MADS::NumericalValue* CreateTagRequest::unsafe_arena_release_numerical() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.CreateTagRequest.numerical)
  if (_internal_has_numerical()) {
    clear_has_value();
    ::MADS::NumericalValue* temp = value_.numerical_;
    value_.numerical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateTagRequest::unsafe_arena_set_allocated_numerical(::MADS::NumericalValue* numerical) {
  clear_value();
  if (numerical) {
    set_has_numerical();
    value_.numerical_ = numerical;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.CreateTagRequest.numerical)
}
inline ::MADS::NumericalValue* CreateTagRequest::_internal_mutable_numerical() {
  if (!_internal_has_numerical()) {
    clear_value();
    set_has_numerical();
    value_.numerical_ = CreateMaybeMessage< ::MADS::NumericalValue >(GetArena());
  }
  return value_.numerical_;
}
inline ::MADS::NumericalValue* CreateTagRequest::mutable_numerical() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateTagRequest.numerical)
  return _internal_mutable_numerical();
}

// .MADS.DateValue date = 6;
inline bool CreateTagRequest::_internal_has_date() const {
  return value_case() == kDate;
}
inline bool CreateTagRequest::has_date() const {
  return _internal_has_date();
}
inline void CreateTagRequest::set_has_date() {
  _oneof_case_[0] = kDate;
}
inline void CreateTagRequest::clear_date() {
  if (_internal_has_date()) {
    if (GetArena() == nullptr) {
      delete value_.date_;
    }
    clear_has_value();
  }
}
inline ::MADS::DateValue* CreateTagRequest::release_date() {
  // @@protoc_insertion_point(field_release:MADS.CreateTagRequest.date)
  if (_internal_has_date()) {
    clear_has_value();
      ::MADS::DateValue* temp = value_.date_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::DateValue& CreateTagRequest::_internal_date() const {
  return _internal_has_date()
      ? *value_.date_
      : *reinterpret_cast< ::MADS::DateValue*>(&::MADS::_DateValue_default_instance_);
}
inline const ::MADS::DateValue& CreateTagRequest::date() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagRequest.date)
  return _internal_date();
}
inline ::MADS::DateValue* CreateTagRequest::unsafe_arena_release_date() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.CreateTagRequest.date)
  if (_internal_has_date()) {
    clear_has_value();
    ::MADS::DateValue* temp = value_.date_;
    value_.date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateTagRequest::unsafe_arena_set_allocated_date(::MADS::DateValue* date) {
  clear_value();
  if (date) {
    set_has_date();
    value_.date_ = date;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.CreateTagRequest.date)
}
inline ::MADS::DateValue* CreateTagRequest::_internal_mutable_date() {
  if (!_internal_has_date()) {
    clear_value();
    set_has_date();
    value_.date_ = CreateMaybeMessage< ::MADS::DateValue >(GetArena());
  }
  return value_.date_;
}
inline ::MADS::DateValue* CreateTagRequest::mutable_date() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateTagRequest.date)
  return _internal_mutable_date();
}

// .MADS.TimeValue time = 7;
inline bool CreateTagRequest::_internal_has_time() const {
  return value_case() == kTime;
}
inline bool CreateTagRequest::has_time() const {
  return _internal_has_time();
}
inline void CreateTagRequest::set_has_time() {
  _oneof_case_[0] = kTime;
}
inline void CreateTagRequest::clear_time() {
  if (_internal_has_time()) {
    if (GetArena() == nullptr) {
      delete value_.time_;
    }
    clear_has_value();
  }
}
inline ::MADS::TimeValue* CreateTagRequest::release_time() {
  // @@protoc_insertion_point(field_release:MADS.CreateTagRequest.time)
  if (_internal_has_time()) {
    clear_has_value();
      ::MADS::TimeValue* temp = value_.time_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::TimeValue& CreateTagRequest::_internal_time() const {
  return _internal_has_time()
      ? *value_.time_
      : *reinterpret_cast< ::MADS::TimeValue*>(&::MADS::_TimeValue_default_instance_);
}
inline const ::MADS::TimeValue& CreateTagRequest::time() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagRequest.time)
  return _internal_time();
}
inline ::MADS::TimeValue* CreateTagRequest::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.CreateTagRequest.time)
  if (_internal_has_time()) {
    clear_has_value();
    ::MADS::TimeValue* temp = value_.time_;
    value_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateTagRequest::unsafe_arena_set_allocated_time(::MADS::TimeValue* time) {
  clear_value();
  if (time) {
    set_has_time();
    value_.time_ = time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.CreateTagRequest.time)
}
inline ::MADS::TimeValue* CreateTagRequest::_internal_mutable_time() {
  if (!_internal_has_time()) {
    clear_value();
    set_has_time();
    value_.time_ = CreateMaybeMessage< ::MADS::TimeValue >(GetArena());
  }
  return value_.time_;
}
inline ::MADS::TimeValue* CreateTagRequest::mutable_time() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateTagRequest.time)
  return _internal_mutable_time();
}

// .MADS.RGBValue rgb = 8;
inline bool CreateTagRequest::_internal_has_rgb() const {
  return value_case() == kRgb;
}
inline bool CreateTagRequest::has_rgb() const {
  return _internal_has_rgb();
}
inline void CreateTagRequest::set_has_rgb() {
  _oneof_case_[0] = kRgb;
}
inline void CreateTagRequest::clear_rgb() {
  if (_internal_has_rgb()) {
    if (GetArena() == nullptr) {
      delete value_.rgb_;
    }
    clear_has_value();
  }
}
inline ::MADS::RGBValue* CreateTagRequest::release_rgb() {
  // @@protoc_insertion_point(field_release:MADS.CreateTagRequest.rgb)
  if (_internal_has_rgb()) {
    clear_has_value();
      ::MADS::RGBValue* temp = value_.rgb_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.rgb_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MADS::RGBValue& CreateTagRequest::_internal_rgb() const {
  return _internal_has_rgb()
      ? *value_.rgb_
      : *reinterpret_cast< ::MADS::RGBValue*>(&::MADS::_RGBValue_default_instance_);
}
inline const ::MADS::RGBValue& CreateTagRequest::rgb() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagRequest.rgb)
  return _internal_rgb();
}
inline ::MADS::RGBValue* CreateTagRequest::unsafe_arena_release_rgb() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MADS.CreateTagRequest.rgb)
  if (_internal_has_rgb()) {
    clear_has_value();
    ::MADS::RGBValue* temp = value_.rgb_;
    value_.rgb_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateTagRequest::unsafe_arena_set_allocated_rgb(::MADS::RGBValue* rgb) {
  clear_value();
  if (rgb) {
    set_has_rgb();
    value_.rgb_ = rgb;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.CreateTagRequest.rgb)
}
inline ::MADS::RGBValue* CreateTagRequest::_internal_mutable_rgb() {
  if (!_internal_has_rgb()) {
    clear_value();
    set_has_rgb();
    value_.rgb_ = CreateMaybeMessage< ::MADS::RGBValue >(GetArena());
  }
  return value_.rgb_;
}
inline ::MADS::RGBValue* CreateTagRequest::mutable_rgb() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateTagRequest.rgb)
  return _internal_mutable_rgb();
}

inline bool CreateTagRequest::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void CreateTagRequest::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline CreateTagRequest::ValueCase CreateTagRequest::value_case() const {
  return CreateTagRequest::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateTagResponse

// .MADS.Tag tag = 1;
inline bool CreateTagResponse::_internal_has_tag() const {
  return this != internal_default_instance() && tag_ != nullptr;
}
inline bool CreateTagResponse::has_tag() const {
  return _internal_has_tag();
}
inline void CreateTagResponse::clear_tag() {
  if (GetArena() == nullptr && tag_ != nullptr) {
    delete tag_;
  }
  tag_ = nullptr;
}
inline const ::MADS::Tag& CreateTagResponse::_internal_tag() const {
  const ::MADS::Tag* p = tag_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MADS::Tag*>(
      &::MADS::_Tag_default_instance_);
}
inline const ::MADS::Tag& CreateTagResponse::tag() const {
  // @@protoc_insertion_point(field_get:MADS.CreateTagResponse.tag)
  return _internal_tag();
}
inline void CreateTagResponse::unsafe_arena_set_allocated_tag(
    ::MADS::Tag* tag) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tag_);
  }
  tag_ = tag;
  if (tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MADS.CreateTagResponse.tag)
}
inline ::MADS::Tag* CreateTagResponse::release_tag() {
  
  ::MADS::Tag* temp = tag_;
  tag_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MADS::Tag* CreateTagResponse::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_release:MADS.CreateTagResponse.tag)
  
  ::MADS::Tag* temp = tag_;
  tag_ = nullptr;
  return temp;
}
inline ::MADS::Tag* CreateTagResponse::_internal_mutable_tag() {
  
  if (tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::MADS::Tag>(GetArena());
    tag_ = p;
  }
  return tag_;
}
inline ::MADS::Tag* CreateTagResponse::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:MADS.CreateTagResponse.tag)
  return _internal_mutable_tag();
}
inline void CreateTagResponse::set_allocated_tag(::MADS::Tag* tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tag_;
  }
  if (tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tag);
    if (message_arena != submessage_arena) {
      tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    
  } else {
    
  }
  tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:MADS.CreateTagResponse.tag)
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MADS

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MADS::TagSetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MADS::TagSetType>() {
  return ::MADS::TagSetType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MADS_2eproto
